HIRBuilderTest
---
---
TestReturnNone
---
def test():
  return None
---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v0 = LoadConst<NoneType>
    Return v0
  }
}
---
TestReturnArg
---
def test(x):
  return x
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    Return v0
  }
}
---
TestCompare
---
def test(a, b):
  return a is b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = PrimitiveCompare<Equal> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
---
TestConditionallyAssignLocal
---
def test(a):
    if a:
        b = "foo"
    return b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
      }
    }
    CondBranch<1, 2> v2
  }

  bb 1 (preds 0) {
    Snapshot
    v3 = LoadConst<MortalUnicodeExact["foo"]>
    v1 = Assign v3
    Branch<2>
  }

  bb 2 (preds 0, 1) {
    Snapshot
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
      }
    }
    Return v1
  }
}
---
TestLoadAttr
---
def test(self):
  return self.foo
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "self">
    Snapshot
    v0 = CheckVar<"self"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadAttr<0; "foo"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    Snapshot
    Return v1
  }
}
---
TestCondBranch
---
def test(x):
  if x:
    return True
  return False
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    CondBranch<1, 2> v1
  }

  bb 1 (preds 0) {
    Snapshot
    v2 = LoadConst<ImmortalBool[True]>
    Return v2
  }

  bb 2 (preds 0) {
    Snapshot
    v3 = LoadConst<ImmortalBool[False]>
    Return v3
  }
}
---
TestCall
---
def test(f, x, y, z):
  return f(x, y, z)
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "f">
    v1 = LoadArg<1; "x">
    v2 = LoadArg<2; "y">
    v3 = LoadArg<3; "z">
    Snapshot
    v0 = CheckVar<"f"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<4> v0 v1 v2 v3
      }
    }
    v1 = CheckVar<"x"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<4> v0 v1 v2 v3
        Stack<1> v0
      }
    }
    v2 = CheckVar<"y"> v2 {
      FrameState {
        NextInstrOffset 6
        Locals<4> v0 v1 v2 v3
        Stack<2> v0 v1
      }
    }
    v3 = CheckVar<"z"> v3 {
      FrameState {
        NextInstrOffset 8
        Locals<4> v0 v1 v2 v3
        Stack<3> v0 v1 v2
      }
    }
    v4 = VectorCall<3> v0 v1 v2 v3 {
      FrameState {
        NextInstrOffset 10
        Locals<4> v0 v1 v2 v3
      }
    }
    Snapshot
    Return v4
  }
}
---
TestAssign
---
def test():
  x = 100
  return x
---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v1 = LoadConst<ImmortalLongExact[100]>
    v0 = Assign v1
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Return v0
  }
}
---
InsertJumpsForBlocksThatFallThrough
---
def test(x):
  if x:
    y = 100
  return y
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
      }
    }
    CondBranch<1, 2> v2
  }

  bb 1 (preds 0) {
    Snapshot
    v3 = LoadConst<ImmortalLongExact[100]>
    v1 = Assign v3
    Branch<2>
  }

  bb 2 (preds 0, 1) {
    Snapshot
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
      }
    }
    Return v1
  }
}
---
HandlesIncomingStacksInCanonicalForm
---
def test(x):
  y = True if x else False
  return y
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
      }
    }
    CondBranch<1, 2> v2
  }

  bb 1 (preds 0) {
    Snapshot
    v3 = LoadConst<ImmortalBool[True]>
    v1 = Assign v3
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
      }
    }
    Return v1
  }

  bb 2 (preds 0) {
    Snapshot
    v4 = LoadConst<ImmortalBool[False]>
    v1 = Assign v4
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 18
        Locals<2> v0 v1
      }
    }
    Return v1
  }
}
---
InsertsCopiesToCanonicalizeStacks
---
def test(x, y):
  z = x if x else y
  return z
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<3> v0 v1 v2
      }
    }
    v3 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<3> v0 v1 v2
      }
    }
    CondBranch<1, 2> v3
  }

  bb 1 (preds 0) {
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 6
        Locals<3> v0 v1 v2
      }
    }
    v2 = Assign v0
    v2 = CheckVar<"z"> v2 {
      FrameState {
        NextInstrOffset 10
        Locals<3> v0 v1 v2
      }
    }
    Return v2
  }

  bb 2 (preds 0) {
    Snapshot
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 14
        Locals<3> v0 v1 v2
      }
    }
    v2 = Assign v1
    v2 = CheckVar<"z"> v2 {
      FrameState {
        NextInstrOffset 18
        Locals<3> v0 v1 v2
      }
    }
    Return v2
  }
}
---
TranslatesJumpIfFalseOrPop
---
def test(x, y):
  return x and y
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v3 = Assign v0
    CondBranch<1, 2> v2
  }

  bb 1 (preds 0) {
    Snapshot
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v3 = Assign v1
    Branch<2>
  }

  bb 2 (preds 0, 1) {
    Snapshot
    Return v3
  }
}
---
TranslatesJumpIfTrueOrPop
---
def test(x, y):
  return x or y
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v3 = Assign v0
    CondBranch<2, 1> v2
  }

  bb 1 (preds 0) {
    Snapshot
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v3 = Assign v1
    Branch<2>
  }

  bb 2 (preds 0, 1) {
    Snapshot
    Return v3
  }
}
---
TranslatesLoadGlobal
---
def test():
  return len
---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v0 = LoadGlobalCached<0; "len">
    v0 = GuardIs<0xdeadbeef> v0 {
      Descr 'LOAD_GLOBAL: len'
    }
    Snapshot
    Return v0
  }
}
---
TranslatesStoreAttr
---
def test(x, val):
  x.foo = val
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "val">
    Snapshot
    v1 = CheckVar<"val"> v1 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v1
      }
    }
    v2 = StoreAttr<0; "foo"> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
TranslatesPopTop
---
def test(f, x):
  f(x)
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "f">
    v1 = LoadArg<1; "x">
    Snapshot
    v0 = CheckVar<"f"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"x"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = VectorCall<1> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
TranslatesPopJumpIfTrue
---
def test(x):
  if not x:
    return False
  return True
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    CondBranch<2, 1> v1
  }

  bb 2 (preds 0) {
    Snapshot
    v2 = LoadConst<ImmortalBool[True]>
    Return v2
  }

  bb 1 (preds 0) {
    Snapshot
    v3 = LoadConst<ImmortalBool[False]>
    Return v3
  }
}
---
TranslatesAddPacket
---
def test(self, p, old):
    if self.input is None:
        self.input = p
        self.packet_pending = True
        if self.priority > old.priority:
            return self
    else:
        p.append_to(self.input)
    return old
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "self">
    v1 = LoadArg<1; "p">
    v2 = LoadArg<2; "old">
    Snapshot
    v0 = CheckVar<"self"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<3> v0 v1 v2
      }
    }
    v3 = LoadAttr<0; "input"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<3> v0 v1 v2
      }
    }
    Snapshot
    v4 = LoadConst<NoneType>
    v5 = PrimitiveCompare<Equal> v3 v4
    v6 = PrimitiveBoxBool v5
    v7 = IsTruthy v6 {
      FrameState {
        NextInstrOffset 10
        Locals<3> v0 v1 v2
      }
    }
    CondBranch<1, 4> v7
  }

  bb 1 (preds 0) {
    Snapshot
    v1 = CheckVar<"p"> v1 {
      FrameState {
        NextInstrOffset 12
        Locals<3> v0 v1 v2
      }
    }
    v0 = CheckVar<"self"> v0 {
      FrameState {
        NextInstrOffset 14
        Locals<3> v0 v1 v2
        Stack<1> v1
      }
    }
    v8 = StoreAttr<0; "input"> v0 v1 {
      FrameState {
        NextInstrOffset 16
        Locals<3> v0 v1 v2
      }
    }
    Snapshot
    v9 = LoadConst<ImmortalBool[True]>
    v0 = CheckVar<"self"> v0 {
      FrameState {
        NextInstrOffset 20
        Locals<3> v0 v1 v2
        Stack<1> v9
      }
    }
    v10 = StoreAttr<1; "packet_pending"> v0 v9 {
      FrameState {
        NextInstrOffset 22
        Locals<3> v0 v1 v2
      }
    }
    Snapshot
    v0 = CheckVar<"self"> v0 {
      FrameState {
        NextInstrOffset 24
        Locals<3> v0 v1 v2
      }
    }
    v11 = LoadAttr<2; "priority"> v0 {
      FrameState {
        NextInstrOffset 26
        Locals<3> v0 v1 v2
      }
    }
    Snapshot
    v2 = CheckVar<"old"> v2 {
      FrameState {
        NextInstrOffset 28
        Locals<3> v0 v1 v2
        Stack<1> v11
      }
    }
    v12 = LoadAttr<2; "priority"> v2 {
      FrameState {
        NextInstrOffset 30
        Locals<3> v0 v1 v2
        Stack<1> v11
      }
    }
    Snapshot
    v13 = Compare<GreaterThan> v11 v12 {
      FrameState {
        NextInstrOffset 32
        Locals<3> v0 v1 v2
      }
    }
    Snapshot
    v14 = IsTruthy v13 {
      FrameState {
        NextInstrOffset 34
        Locals<3> v0 v1 v2
      }
    }
    CondBranch<2, 3> v14
  }

  bb 2 (preds 1) {
    Snapshot
    v0 = CheckVar<"self"> v0 {
      FrameState {
        NextInstrOffset 36
        Locals<3> v0 v1 v2
      }
    }
    Return v0
  }

  bb 3 (preds 1) {
    Snapshot
    v2 = CheckVar<"old"> v2 {
      FrameState {
        NextInstrOffset 40
        Locals<3> v0 v1 v2
      }
    }
    Return v2
  }

  bb 4 (preds 0) {
    Snapshot
    v1 = CheckVar<"p"> v1 {
      FrameState {
        NextInstrOffset 44
        Locals<3> v0 v1 v2
      }
    }
    v15 = LoadMethod<3; "append_to"> v1 {
      FrameState {
        NextInstrOffset 46
        Locals<3> v0 v1 v2
      }
    }
    v16 = GetSecondOutput<OptObject> v15
    Snapshot
    v0 = CheckVar<"self"> v0 {
      FrameState {
        NextInstrOffset 48
        Locals<3> v0 v1 v2
        Stack<2> v15 v16
      }
    }
    v17 = LoadAttr<0; "input"> v0 {
      FrameState {
        NextInstrOffset 50
        Locals<3> v0 v1 v2
        Stack<2> v15 v16
      }
    }
    Snapshot
    v18 = CallMethod<3> v15 v16 v17 {
      FrameState {
        NextInstrOffset 52
        Locals<3> v0 v1 v2
      }
    }
    Snapshot
    v2 = CheckVar<"old"> v2 {
      FrameState {
        NextInstrOffset 56
        Locals<3> v0 v1 v2
      }
    }
    Return v2
  }
}
---
TranslatesLoops
---
def test(x, y):
  while x:
    x = y()
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
      }
    }
    CondBranch<4, 3> v2
  }

  bb 4 (preds 0, 1) {
    v7 = LoadEvalBreaker
    CondBranch<5, 1> v7
  }

  bb 5 (preds 4) {
    Snapshot
    v8 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
      }
    }
    Branch<1>
  }

  bb 1 (preds 4, 5) {
    Snapshot
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    v3 = VectorCall<0> v1 {
      FrameState {
        NextInstrOffset 8
        Locals<2> v0 v1
      }
    }
    Snapshot
    v0 = Assign v3
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 12
        Locals<2> v0 v1
      }
    }
    v4 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v0 v1
      }
    }
    CondBranch<4, 2> v4
  }

  bb 2 (preds 1) {
    Snapshot
    v6 = LoadConst<NoneType>
    Return v6
  }

  bb 3 (preds 0) {
    Snapshot
    v5 = LoadConst<NoneType>
    Return v5
  }
}
---
TranslateBlocksWithOnlySetupLoop0
---
def test(self):
    if not self:
        return
    while True:
        self = 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "self">
    Snapshot
    v0 = CheckVar<"self"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    CondBranch<4, 1> v1
  }

  bb 4 (preds 0, 3) {
    v4 = LoadEvalBreaker
    CondBranch<5, 3> v4
  }

  bb 5 (preds 4) {
    Snapshot
    v5 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 10
        Locals<1> v0
      }
    }
    Branch<3>
  }

  bb 3 (preds 4, 5) {
    Snapshot
    v3 = LoadConst<ImmortalLongExact[1]>
    v0 = Assign v3
    Branch<4>
  }

  bb 1 (preds 0) {
    Snapshot
    v2 = LoadConst<NoneType>
    Return v2
  }
}
---
TranslateBlocksWithOnlySetupLoop1
---
def test(self):
    while True:
        self = 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "self">
    Snapshot
    Branch<2>
  }

  bb 2 (preds 0, 1) {
    v2 = LoadEvalBreaker
    CondBranch<3, 1> v2
  }

  bb 3 (preds 2) {
    Snapshot
    v3 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    Branch<1>
  }

  bb 1 (preds 2, 3) {
    Snapshot
    v1 = LoadConst<ImmortalLongExact[1]>
    v0 = Assign v1
    Branch<2>
  }
}
---
EmitCheckExcForGreaterThan
---
def test(x):
  return x > 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<ImmortalLongExact[1]>
    v2 = Compare<GreaterThan> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Snapshot
    Return v2
  }
}
---
EmitCheckExcForGreaterThanEqual
---
def test(x):
  return x >= 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<ImmortalLongExact[1]>
    v2 = Compare<GreaterThanEqual> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Snapshot
    Return v2
  }
}
---
EmitCheckExcForLessThan
---
def test(x):
  return x < 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<ImmortalLongExact[1]>
    v2 = Compare<LessThan> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Snapshot
    Return v2
  }
}
---
EmitCheckExcForLessThanEqual
---
def test(x):
  return x <= 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<ImmortalLongExact[1]>
    v2 = Compare<LessThanEqual> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Snapshot
    Return v2
  }
}
---
EmitCheckExcForEqual
---
def test(x):
  return x == 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<ImmortalLongExact[1]>
    v2 = Compare<Equal> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Snapshot
    Return v2
  }
}
---
EmitCheckExcForNotEqual
---
def test(x):
  return x != 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<ImmortalLongExact[1]>
    v2 = Compare<NotEqual> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Snapshot
    Return v2
  }
}
---
EmitCheckExcForIn
---
def test(x, s):
  return x in s
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "s">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"s"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = Compare<In> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    Return v2
  }
}
---
EmitCheckExcForNotIn
---
def test(x, s):
  return x not in s
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "s">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"s"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = Compare<NotIn> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    Return v2
  }
}
---
DoesntEmitCheckExcForIs
---
def test(x):
  return x is None
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<NoneType>
    v2 = PrimitiveCompare<Equal> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
---
DoesntEmitCheckExcForIsNot
---
def test(x):
  return x is not None
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<NoneType>
    v2 = PrimitiveCompare<NotEqual> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
---
TranslatesBinaryAdd
---
def test(a, b):
  return a + b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<Add> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    Return v2
  }
}
---
TranslatesBinaryAnd
---
def test(a, b):
  return a & b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<And> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    Return v2
  }
}
---
TranslatesBinaryFloorDivide
---
def test(a, b):
  return a // b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<FloorDivide> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    Return v2
  }
}
---
TranslatesBinaryLShift
---
def test(a, b):
  return a << b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<LShift> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    Return v2
  }
}
---
TranslatesBinaryModulo
---
def test(a, b):
  return a % b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<Modulo> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    Return v2
  }
}
---
TranslatesBinaryMultiply
---
def test(a, b):
  return a * b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<Multiply> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    Return v2
  }
}
---
TranslatesBinaryOr
---
def test(a, b):
  return a | b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<Or> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    Return v2
  }
}
---
TranslatesBinaryPower
---
def test(a, b):
  return a ** b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<Power> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    Return v2
  }
}
---
TranslatesBinaryRShift
---
def test(a, b):
  return a >> b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<RShift> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    Return v2
  }
}
---
TranslatesBinarySubscr
---
def test(a, b):
  return a[b]
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<Subscript> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    Return v2
  }
}
---
TranslatesBinarySubtract
---
def test(a, b):
  return a - b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<Subtract> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    Return v2
  }
}
---
TranslatesBinaryTrueDivide
---
def test(a, b):
  return a / b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<TrueDivide> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    Return v2
  }
}
---
TranslatesBinaryXor
---
def test(a, b):
  return a ^ b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = BinaryOp<Xor> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    Return v2
  }
}
---
BuildTuple
---
def test(a):
  return (a, a, a)
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
        Stack<1> v0
      }
    }
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
        Stack<2> v0 v0
      }
    }
    v1 = MakeTuple<3> v0 v0 v0 {
      FrameState {
        NextInstrOffset 8
        Locals<1> v0
        Stack<3> v0 v0 v0
      }
    }
    Snapshot
    Return v1
  }
}
---
BuildList
---
def test(a):
  return [a, a, a]
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
        Stack<1> v0
      }
    }
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
        Stack<2> v0 v0
      }
    }
    v1 = MakeList<3> v0 v0 v0 {
      FrameState {
        NextInstrOffset 8
        Locals<1> v0
        Stack<3> v0 v0 v0
      }
    }
    Snapshot
    Return v1
  }
}
---
UnaryNot
---
def test(a):
  return not a
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = UnaryOp<Not> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    Snapshot
    Return v1
  }
}
---
UnaryPositive
---
def test(a):
  return +a
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = UnaryOp<Positive> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    Snapshot
    Return v1
  }
}
---
UnaryNegative
---
def test(a):
  return -a
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = UnaryOp<Negate> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    Snapshot
    Return v1
  }
}
---
UnaryInvert
---
def test(a):
  return ~a
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = UnaryOp<Invert> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    Snapshot
    Return v1
  }
}
---
StoreSubscr
---
def test(c, s, v):
  c[s] = v
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "c">
    v1 = LoadArg<1; "s">
    v2 = LoadArg<2; "v">
    Snapshot
    v2 = CheckVar<"v"> v2 {
      FrameState {
        NextInstrOffset 2
        Locals<3> v0 v1 v2
      }
    }
    v0 = CheckVar<"c"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<3> v0 v1 v2
        Stack<1> v2
      }
    }
    v1 = CheckVar<"s"> v1 {
      FrameState {
        NextInstrOffset 6
        Locals<3> v0 v1 v2
        Stack<2> v2 v0
      }
    }
    v3 = StoreSubscr v0 v1 v2 {
      FrameState {
        NextInstrOffset 8
        Locals<3> v0 v1 v2
      }
    }
    Snapshot
    v4 = LoadConst<NoneType>
    Return v4
  }
}
---
InPlaceAdd
---
def test(a, b):
  a += b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<Add> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceAnd
---
def test(a, b):
  a &= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<And> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceFloorDivide
---
def test(a, b):
  a //= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<FloorDivide> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceLShift
---
def test(a, b):
  a <<= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<LShift> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceMatrixMultiply
---
def test(a, b):
  a @= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<MatrixMultiply> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceModulo
---
def test(a, b):
  a %= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<Modulo> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceOr
---
def test(a, b):
  a |= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<Or> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlacePower
---
def test(a, b):
  a **= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<Power> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceRShift
---
def test(a, b):
  a >>= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<RShift> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceSubtract
---
def test(a, b):
  a -= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<Subtract> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceTrueDivide
---
def test(a, b):
  a /= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<TrueDivide> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceXor
---
def test(a, b):
  a ^= b
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = InPlaceOp<Xor> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
InPlaceAddNotDefined
---
def test():
  a += b
---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadGlobal<0; "b"> {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
        Stack<1> v0
      }
    }
    Snapshot
    v2 = InPlaceOp<Add> v0 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Snapshot
    v0 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
BuildMap
---
def test(k, v):
  return {k: v, 12: 34}
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "k">
    v1 = LoadArg<1; "v">
    Snapshot
    v0 = CheckVar<"k"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"v"> v1 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v2 = LoadConst<ImmortalLongExact[12]>
    v3 = LoadConst<ImmortalLongExact[34]>
    v4 = MakeDict<2> {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
        Stack<4> v0 v1 v2 v3
      }
    }
    v5 = SetDictItem v4 v0 v1 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
        Stack<4> v0 v1 v2 v3
      }
    }
    v6 = SetDictItem v4 v2 v3 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
        Stack<4> v0 v1 v2 v3
      }
    }
    Snapshot
    Return v4
  }
}
---
BuildConstKeyMap
---
def test():
  return {"a key": "a value", 0xdead: 0xbeef}
---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v0 = LoadConst<MortalUnicodeExact["a value"]>
    v1 = LoadConst<MortalLongExact[48879]>
    v2 = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    v3 = MakeDict<2> {
      FrameState {
        NextInstrOffset 8
        Stack<3> v0 v1 v2
      }
    }
    v4 = LoadTupleItem<0> v2
    v5 = SetDictItem v3 v4 v0 {
      FrameState {
        NextInstrOffset 8
        Stack<2> v0 v1
      }
    }
    v6 = LoadTupleItem<1> v2
    v7 = SetDictItem v3 v6 v1 {
      FrameState {
        NextInstrOffset 8
        Stack<2> v0 v1
      }
    }
    Snapshot
    Return v3
  }
}
---
ExtendedArg
---
def test(
    a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15,
    a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29,
    a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43,
    a44, a45, a46, a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57,
    a58, a59, a60, a61, a62, a63, a64, a65, a66, a67, a68, a69, a70, a71,
    a72, a73, a74, a75, a76, a77, a78, a79, a80, a81, a82, a83, a84, a85,
    a86, a87, a88, a89, a90, a91, a92, a93, a94, a95, a96, a97, a98, a99,
    a100, a101, a102, a103, a104, a105, a106, a107, a108, a109, a110,
    a111, a112, a113, a114, a115, a116, a117, a118, a119, a120, a121,
    a122, a123, a124, a125, a126, a127, a128, a129, a130, a131, a132,
    a133, a134, a135, a136, a137, a138, a139, a140, a141, a142, a143,
    a144, a145, a146, a147, a148, a149, a150, a151, a152, a153, a154,
    a155, a156, a157, a158, a159, a160, a161, a162, a163, a164, a165,
    a166, a167, a168, a169, a170, a171, a172, a173, a174, a175, a176,
    a177, a178, a179, a180, a181, a182, a183, a184, a185, a186, a187,
    a188, a189, a190, a191, a192, a193, a194, a195, a196, a197, a198,
    a199, a200, a201, a202, a203, a204, a205, a206, a207, a208, a209,
    a210, a211, a212, a213, a214, a215, a216, a217, a218, a219, a220,
    a221, a222, a223, a224, a225, a226, a227, a228, a229, a230, a231,
    a232, a233, a234, a235, a236, a237, a238, a239, a240, a241, a242,
    a243, a244, a245, a246, a247, a248, a249, a250, a251, a252, a253,
    a254, a255
  ):
    a10 = 1
    a256 = 1337
    return a256
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a0">
    v1 = LoadArg<1; "a1">
    v2 = LoadArg<2; "a2">
    v3 = LoadArg<3; "a3">
    v4 = LoadArg<4; "a4">
    v5 = LoadArg<5; "a5">
    v6 = LoadArg<6; "a6">
    v7 = LoadArg<7; "a7">
    v8 = LoadArg<8; "a8">
    v9 = LoadArg<9; "a9">
    v10 = LoadArg<10; "a10">
    v11 = LoadArg<11; "a11">
    v12 = LoadArg<12; "a12">
    v13 = LoadArg<13; "a13">
    v14 = LoadArg<14; "a14">
    v15 = LoadArg<15; "a15">
    v16 = LoadArg<16; "a16">
    v17 = LoadArg<17; "a17">
    v18 = LoadArg<18; "a18">
    v19 = LoadArg<19; "a19">
    v20 = LoadArg<20; "a20">
    v21 = LoadArg<21; "a21">
    v22 = LoadArg<22; "a22">
    v23 = LoadArg<23; "a23">
    v24 = LoadArg<24; "a24">
    v25 = LoadArg<25; "a25">
    v26 = LoadArg<26; "a26">
    v27 = LoadArg<27; "a27">
    v28 = LoadArg<28; "a28">
    v29 = LoadArg<29; "a29">
    v30 = LoadArg<30; "a30">
    v31 = LoadArg<31; "a31">
    v32 = LoadArg<32; "a32">
    v33 = LoadArg<33; "a33">
    v34 = LoadArg<34; "a34">
    v35 = LoadArg<35; "a35">
    v36 = LoadArg<36; "a36">
    v37 = LoadArg<37; "a37">
    v38 = LoadArg<38; "a38">
    v39 = LoadArg<39; "a39">
    v40 = LoadArg<40; "a40">
    v41 = LoadArg<41; "a41">
    v42 = LoadArg<42; "a42">
    v43 = LoadArg<43; "a43">
    v44 = LoadArg<44; "a44">
    v45 = LoadArg<45; "a45">
    v46 = LoadArg<46; "a46">
    v47 = LoadArg<47; "a47">
    v48 = LoadArg<48; "a48">
    v49 = LoadArg<49; "a49">
    v50 = LoadArg<50; "a50">
    v51 = LoadArg<51; "a51">
    v52 = LoadArg<52; "a52">
    v53 = LoadArg<53; "a53">
    v54 = LoadArg<54; "a54">
    v55 = LoadArg<55; "a55">
    v56 = LoadArg<56; "a56">
    v57 = LoadArg<57; "a57">
    v58 = LoadArg<58; "a58">
    v59 = LoadArg<59; "a59">
    v60 = LoadArg<60; "a60">
    v61 = LoadArg<61; "a61">
    v62 = LoadArg<62; "a62">
    v63 = LoadArg<63; "a63">
    v64 = LoadArg<64; "a64">
    v65 = LoadArg<65; "a65">
    v66 = LoadArg<66; "a66">
    v67 = LoadArg<67; "a67">
    v68 = LoadArg<68; "a68">
    v69 = LoadArg<69; "a69">
    v70 = LoadArg<70; "a70">
    v71 = LoadArg<71; "a71">
    v72 = LoadArg<72; "a72">
    v73 = LoadArg<73; "a73">
    v74 = LoadArg<74; "a74">
    v75 = LoadArg<75; "a75">
    v76 = LoadArg<76; "a76">
    v77 = LoadArg<77; "a77">
    v78 = LoadArg<78; "a78">
    v79 = LoadArg<79; "a79">
    v80 = LoadArg<80; "a80">
    v81 = LoadArg<81; "a81">
    v82 = LoadArg<82; "a82">
    v83 = LoadArg<83; "a83">
    v84 = LoadArg<84; "a84">
    v85 = LoadArg<85; "a85">
    v86 = LoadArg<86; "a86">
    v87 = LoadArg<87; "a87">
    v88 = LoadArg<88; "a88">
    v89 = LoadArg<89; "a89">
    v90 = LoadArg<90; "a90">
    v91 = LoadArg<91; "a91">
    v92 = LoadArg<92; "a92">
    v93 = LoadArg<93; "a93">
    v94 = LoadArg<94; "a94">
    v95 = LoadArg<95; "a95">
    v96 = LoadArg<96; "a96">
    v97 = LoadArg<97; "a97">
    v98 = LoadArg<98; "a98">
    v99 = LoadArg<99; "a99">
    v100 = LoadArg<100; "a100">
    v101 = LoadArg<101; "a101">
    v102 = LoadArg<102; "a102">
    v103 = LoadArg<103; "a103">
    v104 = LoadArg<104; "a104">
    v105 = LoadArg<105; "a105">
    v106 = LoadArg<106; "a106">
    v107 = LoadArg<107; "a107">
    v108 = LoadArg<108; "a108">
    v109 = LoadArg<109; "a109">
    v110 = LoadArg<110; "a110">
    v111 = LoadArg<111; "a111">
    v112 = LoadArg<112; "a112">
    v113 = LoadArg<113; "a113">
    v114 = LoadArg<114; "a114">
    v115 = LoadArg<115; "a115">
    v116 = LoadArg<116; "a116">
    v117 = LoadArg<117; "a117">
    v118 = LoadArg<118; "a118">
    v119 = LoadArg<119; "a119">
    v120 = LoadArg<120; "a120">
    v121 = LoadArg<121; "a121">
    v122 = LoadArg<122; "a122">
    v123 = LoadArg<123; "a123">
    v124 = LoadArg<124; "a124">
    v125 = LoadArg<125; "a125">
    v126 = LoadArg<126; "a126">
    v127 = LoadArg<127; "a127">
    v128 = LoadArg<128; "a128">
    v129 = LoadArg<129; "a129">
    v130 = LoadArg<130; "a130">
    v131 = LoadArg<131; "a131">
    v132 = LoadArg<132; "a132">
    v133 = LoadArg<133; "a133">
    v134 = LoadArg<134; "a134">
    v135 = LoadArg<135; "a135">
    v136 = LoadArg<136; "a136">
    v137 = LoadArg<137; "a137">
    v138 = LoadArg<138; "a138">
    v139 = LoadArg<139; "a139">
    v140 = LoadArg<140; "a140">
    v141 = LoadArg<141; "a141">
    v142 = LoadArg<142; "a142">
    v143 = LoadArg<143; "a143">
    v144 = LoadArg<144; "a144">
    v145 = LoadArg<145; "a145">
    v146 = LoadArg<146; "a146">
    v147 = LoadArg<147; "a147">
    v148 = LoadArg<148; "a148">
    v149 = LoadArg<149; "a149">
    v150 = LoadArg<150; "a150">
    v151 = LoadArg<151; "a151">
    v152 = LoadArg<152; "a152">
    v153 = LoadArg<153; "a153">
    v154 = LoadArg<154; "a154">
    v155 = LoadArg<155; "a155">
    v156 = LoadArg<156; "a156">
    v157 = LoadArg<157; "a157">
    v158 = LoadArg<158; "a158">
    v159 = LoadArg<159; "a159">
    v160 = LoadArg<160; "a160">
    v161 = LoadArg<161; "a161">
    v162 = LoadArg<162; "a162">
    v163 = LoadArg<163; "a163">
    v164 = LoadArg<164; "a164">
    v165 = LoadArg<165; "a165">
    v166 = LoadArg<166; "a166">
    v167 = LoadArg<167; "a167">
    v168 = LoadArg<168; "a168">
    v169 = LoadArg<169; "a169">
    v170 = LoadArg<170; "a170">
    v171 = LoadArg<171; "a171">
    v172 = LoadArg<172; "a172">
    v173 = LoadArg<173; "a173">
    v174 = LoadArg<174; "a174">
    v175 = LoadArg<175; "a175">
    v176 = LoadArg<176; "a176">
    v177 = LoadArg<177; "a177">
    v178 = LoadArg<178; "a178">
    v179 = LoadArg<179; "a179">
    v180 = LoadArg<180; "a180">
    v181 = LoadArg<181; "a181">
    v182 = LoadArg<182; "a182">
    v183 = LoadArg<183; "a183">
    v184 = LoadArg<184; "a184">
    v185 = LoadArg<185; "a185">
    v186 = LoadArg<186; "a186">
    v187 = LoadArg<187; "a187">
    v188 = LoadArg<188; "a188">
    v189 = LoadArg<189; "a189">
    v190 = LoadArg<190; "a190">
    v191 = LoadArg<191; "a191">
    v192 = LoadArg<192; "a192">
    v193 = LoadArg<193; "a193">
    v194 = LoadArg<194; "a194">
    v195 = LoadArg<195; "a195">
    v196 = LoadArg<196; "a196">
    v197 = LoadArg<197; "a197">
    v198 = LoadArg<198; "a198">
    v199 = LoadArg<199; "a199">
    v200 = LoadArg<200; "a200">
    v201 = LoadArg<201; "a201">
    v202 = LoadArg<202; "a202">
    v203 = LoadArg<203; "a203">
    v204 = LoadArg<204; "a204">
    v205 = LoadArg<205; "a205">
    v206 = LoadArg<206; "a206">
    v207 = LoadArg<207; "a207">
    v208 = LoadArg<208; "a208">
    v209 = LoadArg<209; "a209">
    v210 = LoadArg<210; "a210">
    v211 = LoadArg<211; "a211">
    v212 = LoadArg<212; "a212">
    v213 = LoadArg<213; "a213">
    v214 = LoadArg<214; "a214">
    v215 = LoadArg<215; "a215">
    v216 = LoadArg<216; "a216">
    v217 = LoadArg<217; "a217">
    v218 = LoadArg<218; "a218">
    v219 = LoadArg<219; "a219">
    v220 = LoadArg<220; "a220">
    v221 = LoadArg<221; "a221">
    v222 = LoadArg<222; "a222">
    v223 = LoadArg<223; "a223">
    v224 = LoadArg<224; "a224">
    v225 = LoadArg<225; "a225">
    v226 = LoadArg<226; "a226">
    v227 = LoadArg<227; "a227">
    v228 = LoadArg<228; "a228">
    v229 = LoadArg<229; "a229">
    v230 = LoadArg<230; "a230">
    v231 = LoadArg<231; "a231">
    v232 = LoadArg<232; "a232">
    v233 = LoadArg<233; "a233">
    v234 = LoadArg<234; "a234">
    v235 = LoadArg<235; "a235">
    v236 = LoadArg<236; "a236">
    v237 = LoadArg<237; "a237">
    v238 = LoadArg<238; "a238">
    v239 = LoadArg<239; "a239">
    v240 = LoadArg<240; "a240">
    v241 = LoadArg<241; "a241">
    v242 = LoadArg<242; "a242">
    v243 = LoadArg<243; "a243">
    v244 = LoadArg<244; "a244">
    v245 = LoadArg<245; "a245">
    v246 = LoadArg<246; "a246">
    v247 = LoadArg<247; "a247">
    v248 = LoadArg<248; "a248">
    v249 = LoadArg<249; "a249">
    v250 = LoadArg<250; "a250">
    v251 = LoadArg<251; "a251">
    v252 = LoadArg<252; "a252">
    v253 = LoadArg<253; "a253">
    v254 = LoadArg<254; "a254">
    v255 = LoadArg<255; "a255">
    Snapshot
    v257 = LoadConst<ImmortalLongExact[1]>
    v10 = Assign v257
    v258 = LoadConst<MortalLongExact[1337]>
    v256 = Assign v258
    v256 = CheckVar<"a256"> v256 {
      FrameState {
        NextInstrOffset 14
        Locals<257> v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15 v16 v17 v18 v19 v20 v21 v22 v23 v24 v25 v26 v27 v28 v29 v30 v31 v32 v33 v34 v35 v36 v37 v38 v39 v40 v41 v42 v43 v44 v45 v46 v47 v48 v49 v50 v51 v52 v53 v54 v55 v56 v57 v58 v59 v60 v61 v62 v63 v64 v65 v66 v67 v68 v69 v70 v71 v72 v73 v74 v75 v76 v77 v78 v79 v80 v81 v82 v83 v84 v85 v86 v87 v88 v89 v90 v91 v92 v93 v94 v95 v96 v97 v98 v99 v100 v101 v102 v103 v104 v105 v106 v107 v108 v109 v110 v111 v112 v113 v114 v115 v116 v117 v118 v119 v120 v121 v122 v123 v124 v125 v126 v127 v128 v129 v130 v131 v132 v133 v134 v135 v136 v137 v138 v139 v140 v141 v142 v143 v144 v145 v146 v147 v148 v149 v150 v151 v152 v153 v154 v155 v156 v157 v158 v159 v160 v161 v162 v163 v164 v165 v166 v167 v168 v169 v170 v171 v172 v173 v174 v175 v176 v177 v178 v179 v180 v181 v182 v183 v184 v185 v186 v187 v188 v189 v190 v191 v192 v193 v194 v195 v196 v197 v198 v199 v200 v201 v202 v203 v204 v205 v206 v207 v208 v209 v210 v211 v212 v213 v214 v215 v216 v217 v218 v219 v220 v221 v222 v223 v224 v225 v226 v227 v228 v229 v230 v231 v232 v233 v234 v235 v236 v237 v238 v239 v240 v241 v242 v243 v244 v245 v246 v247 v248 v249 v250 v251 v252 v253 v254 v255 v256
      }
    }
    Return v256
  }
}
---
BuildSliceNoStep
---
def test(a):
  return a[1:5]
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<ImmortalLongExact[1]>
    v2 = LoadConst<ImmortalLongExact[5]>
    v3 = BuildSlice<2> v1 v2 {
      FrameState {
        NextInstrOffset 8
        Locals<1> v0
        Stack<1> v0
      }
    }
    Snapshot
    v4 = BinaryOp<Subscript> v0 v3 {
      FrameState {
        NextInstrOffset 10
        Locals<1> v0
      }
    }
    Snapshot
    Return v4
  }
}
---
BuildSliceWithStep
---
def test(a):
  return a[100:20:-2]
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadConst<ImmortalLongExact[100]>
    v2 = LoadConst<ImmortalLongExact[20]>
    v3 = LoadConst<ImmortalLongExact[-2]>
    v4 = BuildSlice<3> v1 v2 v3 {
      FrameState {
        NextInstrOffset 10
        Locals<1> v0
        Stack<1> v0
      }
    }
    Snapshot
    v5 = BinaryOp<Subscript> v0 v4 {
      FrameState {
        NextInstrOffset 12
        Locals<1> v0
      }
    }
    Snapshot
    Return v5
  }
}
---
ReassignsOnStackRegistersOnOverwrite
---
def test(a, b):
  a, b = b, a
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v1
      }
    }
    v2 = Assign v0
    v0 = Assign v1
    v1 = Assign v2
    v3 = LoadConst<NoneType>
    Return v3
  }
}
---
HandlesEmptyInfiniteLoops
---
def test():
  while True:
    pass

---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    Branch<2>
  }

  bb 2 (preds 0, 2, 3) {
    v0 = LoadEvalBreaker
    CondBranch<3, 2> v0
  }

  bb 3 (preds 2) {
    Snapshot
    v1 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
      }
    }
    Branch<2>
  }
}
---
ForIterTest
---
def test(xs):
  for x in xs:
    print(x)
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "xs">
    Snapshot
    v0 = CheckVar<"xs"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = GetIter v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
      }
    }
    Snapshot
    Branch<4>
  }

  bb 4 (preds 0, 2) {
    v7 = LoadEvalBreaker
    CondBranch<5, 1> v7
  }

  bb 5 (preds 4) {
    Snapshot
    v8 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    Branch<1>
  }

  bb 1 (preds 4, 5) {
    Snapshot
    v3 = InvokeIterNext v2 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    CondBranchIterNotDone<2, 3> v3
  }

  bb 2 (preds 1) {
    Snapshot
    v1 = Assign v3
    v4 = LoadGlobalCached<0; "print">
    v4 = GuardIs<0xdeadbeef> v4 {
      Descr 'LOAD_GLOBAL: print'
    }
    Snapshot
    v1 = CheckVar<"x"> v1 {
      FrameState {
        NextInstrOffset 12
        Locals<2> v0 v1
        Stack<2> v2 v4
      }
    }
    v5 = VectorCall<1> v4 v1 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    Snapshot
    Branch<4>
  }

  bb 3 (preds 1) {
    Snapshot
    v6 = LoadConst<NoneType>
    Return v6
  }
}
---
ListComprehension
---
def test(a):
  return [i for i in a]
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    Snapshot
    v1 = LoadConst<MortalCode["<listcomp>"]>
    v2 = LoadConst<MortalUnicodeExact["test.<locals>.<listc"...]>
    v3 = MakeFunction v2 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 8
        Locals<1> v0
        Stack<1> v3
      }
    }
    v4 = GetIter v0 {
      FrameState {
        NextInstrOffset 10
        Locals<1> v0
        Stack<1> v3
      }
    }
    Snapshot
    v5 = VectorCall<1> v3 v4 {
      FrameState {
        NextInstrOffset 12
        Locals<1> v0
      }
    }
    Snapshot
    Return v5
  }
}
---
NestedFunction
---
def test(a):
  def nested(a=a):
    return a
  return nested
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = MakeTuple<1> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    Snapshot
    v3 = LoadConst<MortalCode["nested"]>
    v4 = LoadConst<MortalUnicodeExact["test.<locals>.nested"]>
    v5 = MakeFunction v4 v3 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    SetFunctionAttr<func_defaults> v2 v5
    Snapshot
    v1 = Assign v5
    v1 = CheckVar<"nested"> v1 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v0 v1
      }
    }
    Return v1
  }
}
---
Cellvar
---
def test():
  a = 1
  def g():
    return a
  return g
---
fun jittestmodule:test {
  bb 0 {
    v1 = MakeCell v2 {
      FrameState {
        NextInstrOffset 0
        Locals<1> v0
        Cells<1> v1
      }
    }
    Snapshot
    v3 = LoadConst<ImmortalLongExact[1]>
    v4 = StealCellItem v1
    SetCellItem v1 v3 v4
    Snapshot
    v5 = MakeTuple<1> v1 {
      FrameState {
        NextInstrOffset 8
        Locals<1> v0
        Cells<1> v1
        Stack<1> v1
      }
    }
    Snapshot
    v6 = LoadConst<MortalCode["g"]>
    v7 = LoadConst<MortalUnicodeExact["test.<locals>.g"]>
    v8 = MakeFunction v7 v6 {
      FrameState {
        NextInstrOffset 14
        Locals<1> v0
        Cells<1> v1
        Stack<1> v5
      }
    }
    SetFunctionAttr<func_closure> v5 v8
    Snapshot
    v0 = Assign v8
    v0 = CheckVar<"g"> v0 {
      FrameState {
        NextInstrOffset 18
        Locals<1> v0
        Cells<1> v1
      }
    }
    Return v0
  }
}
---
CellvarArgument
---
def test(a):
  def g():
    return a
  return g
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v2 = MakeCell v0 {
      FrameState {
        NextInstrOffset 0
        Locals<2> v0 v1
        Cells<1> v2
      }
    }
    Snapshot
    v4 = MakeTuple<1> v2 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v3 v1
        Cells<1> v2
        Stack<1> v2
      }
    }
    Snapshot
    v5 = LoadConst<MortalCode["g"]>
    v6 = LoadConst<MortalUnicodeExact["test.<locals>.g"]>
    v7 = MakeFunction v6 v5 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v3 v1
        Cells<1> v2
        Stack<1> v4
      }
    }
    SetFunctionAttr<func_closure> v4 v7
    Snapshot
    v1 = Assign v7
    v1 = CheckVar<"g"> v1 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v3 v1
        Cells<1> v2
      }
    }
    Return v1
  }
}
---
CellvarWithStackLoadAndBlockCanonicalization
---
def test(a):
  def g():
    return a
  for x in g():
    pass
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v3 = MakeCell v0 {
      FrameState {
        NextInstrOffset 0
        Locals<3> v0 v1 v2
        Cells<1> v3
      }
    }
    Snapshot
    v5 = MakeTuple<1> v3 {
      FrameState {
        NextInstrOffset 4
        Locals<3> v4 v1 v2
        Cells<1> v3
        Stack<1> v3
      }
    }
    Snapshot
    v6 = LoadConst<MortalCode["g"]>
    v7 = LoadConst<MortalUnicodeExact["test.<locals>.g"]>
    v8 = MakeFunction v7 v6 {
      FrameState {
        NextInstrOffset 10
        Locals<3> v4 v1 v2
        Cells<1> v3
        Stack<1> v5
      }
    }
    SetFunctionAttr<func_closure> v5 v8
    Snapshot
    v1 = Assign v8
    v1 = CheckVar<"g"> v1 {
      FrameState {
        NextInstrOffset 14
        Locals<3> v4 v1 v2
        Cells<1> v3
      }
    }
    v9 = VectorCall<0> v1 {
      FrameState {
        NextInstrOffset 16
        Locals<3> v4 v1 v2
        Cells<1> v3
      }
    }
    Snapshot
    v10 = GetIter v9 {
      FrameState {
        NextInstrOffset 18
        Locals<3> v4 v1 v2
        Cells<1> v3
      }
    }
    Snapshot
    v5 = Assign v10
    Branch<4>
  }

  bb 4 (preds 0, 2) {
    v13 = LoadEvalBreaker
    CondBranch<5, 1> v13
  }

  bb 5 (preds 4) {
    Snapshot
    v14 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 18
        Locals<3> v4 v1 v2
        Cells<1> v3
        Stack<1> v5
      }
    }
    Branch<1>
  }

  bb 1 (preds 4, 5) {
    Snapshot
    v11 = InvokeIterNext v5 {
      FrameState {
        NextInstrOffset 20
        Locals<3> v4 v1 v2
        Cells<1> v3
        Stack<1> v5
      }
    }
    v6 = Assign v11
    CondBranchIterNotDone<2, 3> v6
  }

  bb 2 (preds 1) {
    Snapshot
    v2 = Assign v6
    Branch<4>
  }

  bb 3 (preds 1) {
    Snapshot
    v12 = LoadConst<NoneType>
    Return v12
  }
}
---
LoopWithBreak1
---
def test():
  while True:
    break
---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v0 = LoadConst<NoneType>
    Return v0
  }
}
---
LoopWithBreak2
---
def test(x, y):
  while x < 10:
    if x == y:
      break
    x += 1
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<2> v0 v1
      }
    }
    v2 = LoadConst<ImmortalLongExact[10]>
    v3 = Compare<LessThan> v0 v2 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    v4 = IsTruthy v3 {
      FrameState {
        NextInstrOffset 8
        Locals<2> v0 v1
      }
    }
    CondBranch<6, 5> v4
  }

  bb 6 (preds 0, 3) {
    v15 = LoadEvalBreaker
    CondBranch<7, 1> v15
  }

  bb 7 (preds 6) {
    Snapshot
    v16 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 8
        Locals<2> v0 v1
      }
    }
    Branch<1>
  }

  bb 1 (preds 6, 7) {
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
      }
    }
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 12
        Locals<2> v0 v1
        Stack<1> v0
      }
    }
    v5 = Compare<Equal> v0 v1 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v0 v1
      }
    }
    Snapshot
    v6 = IsTruthy v5 {
      FrameState {
        NextInstrOffset 16
        Locals<2> v0 v1
      }
    }
    CondBranch<2, 3> v6
  }

  bb 2 (preds 1) {
    Snapshot
    v8 = LoadConst<NoneType>
    Return v8
  }

  bb 3 (preds 1) {
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 22
        Locals<2> v0 v1
      }
    }
    v9 = LoadConst<ImmortalLongExact[1]>
    v10 = InPlaceOp<Add> v0 v9 {
      FrameState {
        NextInstrOffset 26
        Locals<2> v0 v1
      }
    }
    Snapshot
    v0 = Assign v10
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 30
        Locals<2> v0 v1
      }
    }
    v11 = LoadConst<ImmortalLongExact[10]>
    v12 = Compare<LessThan> v0 v11 {
      FrameState {
        NextInstrOffset 34
        Locals<2> v0 v1
      }
    }
    Snapshot
    v13 = IsTruthy v12 {
      FrameState {
        NextInstrOffset 36
        Locals<2> v0 v1
      }
    }
    CondBranch<6, 4> v13
  }

  bb 4 (preds 3) {
    Snapshot
    v14 = LoadConst<NoneType>
    Return v14
  }

  bb 5 (preds 0) {
    Snapshot
    v7 = LoadConst<NoneType>
    Return v7
  }
}
---
LoopWithBreak3
---
def test(x):
  for i in [1, 2]:
    if i > x:
      break
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    Snapshot
    v2 = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    v3 = GetIter v2 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
      }
    }
    Snapshot
    v2 = Assign v3
    Branch<6>
  }

  bb 6 (preds 0, 2) {
    v9 = LoadEvalBreaker
    CondBranch<7, 1> v9
  }

  bb 7 (preds 6) {
    Snapshot
    v10 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    Branch<1>
  }

  bb 1 (preds 6, 7) {
    Snapshot
    v4 = InvokeIterNext v2 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    v3 = Assign v4
    CondBranchIterNotDone<2, 5> v3
  }

  bb 2 (preds 1) {
    Snapshot
    v1 = Assign v3
    v1 = CheckVar<"i"> v1 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 12
        Locals<2> v0 v1
        Stack<2> v2 v1
      }
    }
    v5 = Compare<GreaterThan> v1 v0 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    Snapshot
    v6 = IsTruthy v5 {
      FrameState {
        NextInstrOffset 16
        Locals<2> v0 v1
        Stack<1> v2
      }
    }
    CondBranch<3, 6> v6
  }

  bb 3 (preds 2) {
    Snapshot
    v8 = LoadConst<NoneType>
    Return v8
  }

  bb 5 (preds 1) {
    Snapshot
    v7 = LoadConst<NoneType>
    Return v7
  }
}
---
ImportName
---
def test():
  import test_import
---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v1 = LoadConst<ImmortalLongExact[0]>
    v2 = LoadConst<NoneType>
    v3 = ImportName<0; "test_import"> v2 v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Snapshot
    v0 = Assign v3
    v4 = LoadConst<NoneType>
    Return v4
  }
}
---
EscapedName
---
def test(a):
    return a.foo

c = test.__code__
new_names = ("a\nrea\\lly\n\"weird\"\nname", )
test.__code__ = type(c)(
    c.co_argcount,
    c.co_posonlyargcount,
    c.co_kwonlyargcount,
    c.co_nlocals,
    c.co_stacksize,
    c.co_flags,
    c.co_code,
    c.co_consts,
    new_names,
    c.co_varnames,
    c.co_filename,
    c.co_name,
    c.co_firstlineno,
    c.co_lnotab,
    c.co_freevars,
    c.co_cellvars,
)
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    v1 = LoadAttr<0; "a\nrea\\lly\n\"weird\"\nname"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    Snapshot
    Return v1
  }
}
---
GetIterOutputNotOnStack
---
def test():
    while True:
        args = ["-W%s" % o for o in warnopts]
        if args:
            return
---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    Branch<4>
  }

  bb 4 (preds 0, 1) {
    v9 = LoadEvalBreaker
    CondBranch<5, 1> v9
  }

  bb 5 (preds 4) {
    Snapshot
    v10 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    Branch<1>
  }

  bb 1 (preds 4, 5) {
    Snapshot
    v1 = LoadConst<MortalCode["<listcomp>"]>
    v2 = LoadConst<MortalUnicodeExact["test.<locals>.<listc"...]>
    v3 = MakeFunction v2 v1 {
      FrameState {
        NextInstrOffset 8
        Locals<1> v0
      }
    }
    Snapshot
    v4 = LoadGlobal<0; "warnopts"> {
      FrameState {
        NextInstrOffset 10
        Locals<1> v0
        Stack<1> v3
      }
    }
    Snapshot
    v5 = GetIter v4 {
      FrameState {
        NextInstrOffset 12
        Locals<1> v0
        Stack<1> v3
      }
    }
    Snapshot
    v6 = VectorCall<1> v3 v5 {
      FrameState {
        NextInstrOffset 14
        Locals<1> v0
      }
    }
    Snapshot
    v0 = Assign v6
    v0 = CheckVar<"args"> v0 {
      FrameState {
        NextInstrOffset 18
        Locals<1> v0
      }
    }
    v7 = IsTruthy v0 {
      FrameState {
        NextInstrOffset 20
        Locals<1> v0
      }
    }
    CondBranch<2, 4> v7
  }

  bb 2 (preds 1) {
    Snapshot
    v8 = LoadConst<NoneType>
    Return v8
  }
}
---
MaintainsIsolatedEntry
---
def test():
    while True:
        x = foo()
        if x != 0:
            return x
---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    Branch<4>
  }

  bb 4 (preds 0, 1) {
    v6 = LoadEvalBreaker
    CondBranch<5, 1> v6
  }

  bb 5 (preds 4) {
    Snapshot
    v7 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<1> v0
      }
    }
    Branch<1>
  }

  bb 1 (preds 4, 5) {
    Snapshot
    v1 = LoadGlobal<0; "foo"> {
      FrameState {
        NextInstrOffset 4
        Locals<1> v0
      }
    }
    Snapshot
    v2 = VectorCall<0> v1 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v0
      }
    }
    Snapshot
    v0 = Assign v2
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 10
        Locals<1> v0
      }
    }
    v3 = LoadConst<ImmortalLongExact[0]>
    v4 = Compare<NotEqual> v0 v3 {
      FrameState {
        NextInstrOffset 14
        Locals<1> v0
      }
    }
    Snapshot
    v5 = IsTruthy v4 {
      FrameState {
        NextInstrOffset 16
        Locals<1> v0
      }
    }
    CondBranch<2, 4> v5
  }

  bb 2 (preds 1) {
    Snapshot
    v0 = CheckVar<"x"> v0 {
      FrameState {
        NextInstrOffset 18
        Locals<1> v0
      }
    }
    Return v0
  }
}
---
TestFString
---
def test(a, b):
    c = f"{a}"
    d = f"{b:02}"
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = LoadArg<1; "b">
    Snapshot
    v0 = CheckVar<"a"> v0 {
      FrameState {
        NextInstrOffset 2
        Locals<4> v0 v1 v2 v3
      }
    }
    v4 = LoadConst<Nullptr>
    v5 = FormatValue<None> v4 v0 {
      FrameState {
        NextInstrOffset 4
        Locals<4> v0 v1 v2 v3
      }
    }
    Snapshot
    v2 = Assign v5
    v1 = CheckVar<"b"> v1 {
      FrameState {
        NextInstrOffset 8
        Locals<4> v0 v1 v2 v3
      }
    }
    v6 = LoadConst<MortalUnicodeExact["02"]>
    v7 = FormatValue<None> v6 v1 {
      FrameState {
        NextInstrOffset 12
        Locals<4> v0 v1 v2 v3
      }
    }
    Snapshot
    v3 = Assign v7
    v8 = LoadConst<NoneType>
    Return v8
  }
}
---
TestAsyncFor
---
async def test(asyncgen):
  async for y in asyncgen:
    print(y)
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "asyncgen">
    v2 = InitialYield {
      FrameState {
        NextInstrOffset 0
        Locals<2> v0 v1
      }
    }
    Snapshot
    v0 = CheckVar<"asyncgen"> v0 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v0 v1
      }
    }
    v3 = GetAIter v0 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v0 v1
      }
    }
    Snapshot
    Branch<6>
  }

  bb 6 (preds 0, 4) {
    v12 = LoadEvalBreaker
    CondBranch<7, 1> v12
  }

  bb 7 (preds 6) {
    Snapshot
    v13 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 8
        Locals<2> v0 v1
        Stack<1> v3
        BlockStack {
          Opcode 122 HandlerOff 28 StackLevel 1
        }
      }
    }
    Branch<1>
  }

  bb 1 (preds 6, 7) {
    Snapshot
    v4 = GetANext v3 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v0 v1
        Stack<1> v3
        BlockStack {
          Opcode 122 HandlerOff 28 StackLevel 1
        }
      }
    }
    Snapshot
    v5 = LoadConst<NoneType>
    SetCurrentAwaiter v4
    v6 = YieldFromHandleStopAsyncIteration v5 v4 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v0 v1
        Stack<2> v3 v4
        BlockStack {
          Opcode 122 HandlerOff 28 StackLevel 1
        }
      }
    }
    v4 = Assign v6
    CondBranchIterNotDone<2, 3> v4
  }

  bb 2 (preds 1) {
    Snapshot
    v7 = LoadEvalBreaker
    CondBranch<5, 4> v7
  }

  bb 5 (preds 2) {
    Snapshot
    v8 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 16
        Locals<2> v0 v1
        Stack<2> v3 v4
        BlockStack {
          Opcode 122 HandlerOff 28 StackLevel 1
        }
      }
    }
    Branch<4>
  }

  bb 4 (preds 2, 5) {
    Snapshot
    v1 = Assign v4
    v9 = LoadGlobalCached<0; "print">
    v9 = GuardIs<0xdeadbeef> v9 {
      Descr 'LOAD_GLOBAL: print'
    }
    Snapshot
    v1 = CheckVar<"y"> v1 {
      FrameState {
        NextInstrOffset 22
        Locals<2> v0 v1
        Stack<2> v3 v9
      }
    }
    v10 = VectorCall<1> v9 v1 {
      FrameState {
        NextInstrOffset 24
        Locals<2> v0 v1
        Stack<1> v3
      }
    }
    Snapshot
    Branch<6>
  }

  bb 3 (preds 1) {
    Snapshot
    v11 = LoadConst<NoneType>
    Return v11
  }
}
---
TestMakeSet
---
def test():
  return {1,2,3}
---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v0 = MakeSet {
      FrameState {
        NextInstrOffset 2
      }
    }
    Snapshot
    v1 = LoadConst<MortalObjectUser[frozenset:0xdeadbeef]>
    v2 = SetUpdate v0 v1 {
      FrameState {
        NextInstrOffset 6
        Stack<1> v0
      }
    }
    Snapshot
    Return v0
  }
}
---
StarargsIsRefinedToTupleExact
---
def test(x, y, *args):
  return args
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    v2 = LoadArg<2; "args", TupleExact>
    Snapshot
    v2 = CheckVar<"args"> v2 {
      FrameState {
        NextInstrOffset 2
        Locals<3> v0 v1 v2
      }
    }
    Return v2
  }
}
---
StarargsIsRefinedToTupleExactWithKwonlyArgs
---
def test(x, y, *args, kwonly=None):
  return args
---
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    v2 = LoadArg<2; "kwonly">
    v3 = LoadArg<3; "args", TupleExact>
    Snapshot
    v3 = CheckVar<"args"> v3 {
      FrameState {
        NextInstrOffset 2
        Locals<4> v0 v1 v2 v3
      }
    }
    Return v3
  }
}
---
