--- Test Suite Name ---
SimplifyTest
--- Passes ---
Simplify
--- Test Name ---
LoadTupleItemToLoadConst
--- Input ---
def test(a, b):
    baddict = {
        "aaa": a,
        "bbb": b}

    return baddict
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v9:Object = LoadArg<0; "a">
    v10:Object = LoadArg<1; "b">
    v11:Nullptr = LoadConst<Nullptr>
    Snapshot
    v14:MortalTupleExact[tuple:0xdeadbeef] = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    v15:MortalDictExact = MakeDict<2> {
      FrameState {
        NextInstrOffset 8
        Locals<3> v9 v10 v11
        Stack<3> v9 v10 v14
      }
    }
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v14
    v22:MortalUnicodeExact["aaa"] = LoadConst<MortalUnicodeExact["aaa"]>
    v17:CInt32 = SetDictItem v15 v22 v9 {
      FrameState {
        NextInstrOffset 8
        Locals<3> v9 v10 v11
        Stack<2> v9 v10
      }
    }
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v14
    v23:MortalUnicodeExact["bbb"] = LoadConst<MortalUnicodeExact["bbb"]>
    v19:CInt32 = SetDictItem v15 v23 v10 {
      FrameState {
        NextInstrOffset 8
        Locals<3> v9 v10 v11
        Stack<2> v9 v10
      }
    }
    Snapshot
    Return v15
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v12:Object = LoadArg<0; "a">
    v13:Object = LoadArg<1; "b">
    v14:Func = LoadCurrentFunc
    v15:Nullptr = LoadConst<Nullptr>
    Snapshot
    v16:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v16
  }

  bb 2 (preds 0) {
    Snapshot
    v17:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<3> v12 v13 v15
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v23:MortalTupleExact[tuple:0xdeadbeef] = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    v24:MortalDictExact = MakeDict<2> {
      FrameState {
        NextInstrOffset 10
        Locals<3> v12 v13 v15
        Stack<3> v12 v13 v23
      }
    }
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v23
    v31:ImmortalUnicodeExact["aaa"] = LoadConst<ImmortalUnicodeExact["aaa"]>
    v26:CInt32 = SetDictItem v24 v31 v12 {
      FrameState {
        NextInstrOffset 10
        Locals<3> v12 v13 v15
        Stack<2> v12 v13
      }
    }
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v23
    v32:ImmortalUnicodeExact["bbb"] = LoadConst<ImmortalUnicodeExact["bbb"]>
    v28:CInt32 = SetDictItem v24 v32 v13 {
      FrameState {
        NextInstrOffset 10
        Locals<3> v12 v13 v15
        Stack<2> v12 v13
      }
    }
    Snapshot
    Return v24
  }
}
--- Test Name ---
LoadConstRedundantConversion
--- Input ---
from __static__ import box, int64

def test():
    x: int64 = 0
    return box(x)
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v4:Nullptr = LoadConst<Nullptr>
    Snapshot
    v5:ImmortalLongExact[0] = LoadConst<ImmortalLongExact[0]>
    v7:OptObject = LoadGlobalCached<0; "box">
    v8:MortalFunc[function:0xdeadbeef] = GuardIs<0xdeadbeef> v7 {
      Descr 'LOAD_GLOBAL: box'
    }
    Snapshot
    v10:Object = VectorCall<1> v8 v5 {
      FrameState {
        NextInstrOffset 10
        Locals<1> v5
      }
    }
    Snapshot
    Return v10
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v8:Func = LoadCurrentFunc
    v9:Nullptr = LoadConst<Nullptr>
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<1> v9
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v13:ImmortalLongExact[0] = LoadConst<ImmortalLongExact[0]>
    v15:Nullptr = LoadConst<Nullptr>
    v16:OptObject = LoadGlobalCached<0; "box">
    v17:MortalFunc[function:0xdeadbeef] = GuardIs<0xdeadbeef> v16 {
      Descr 'LOAD_GLOBAL: box'
    }
    Snapshot
    v19:Object = CallMethod<3> v15 v17 v13 {
      FrameState {
        NextInstrOffset 20
        Locals<1> v13
      }
    }
    Snapshot
    Return v19
  }
}
--- Test Name ---
ArgumentsAreUnchecked
--- Input ---
def test(x):
  return x
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v1:Object = LoadArg<0; "x">
    Snapshot
    Return v1
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v4:Object = LoadArg<0; "x">
    v5:Func = LoadCurrentFunc
    Snapshot
    v6:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v6
  }

  bb 2 (preds 0) {
    Snapshot
    v7:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<1> v4
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    Return v4
  }
}
--- Test Name ---
VariablesAreUncheckedWhenAssigned
--- Input ---
def test():
  x = 1
  return x
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v2:Nullptr = LoadConst<Nullptr>
    Snapshot
    v3:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    Return v3
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v5:Func = LoadCurrentFunc
    v6:Nullptr = LoadConst<Nullptr>
    Snapshot
    v7:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v7
  }

  bb 2 (preds 0) {
    Snapshot
    v8:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<1> v6
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v10:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    Return v10
  }
}
--- Test Name ---
VariablesAreCheckedIfConditionallyAssigned
--- Input ---
def test(x):
  if x:
    y = 1
  return y
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v4:Object = LoadArg<0; "x">
    v5:Nullptr = LoadConst<Nullptr>
    Snapshot
    v7:CInt32 = IsTruthy v4 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v4 v5
      }
    }
    CondBranch<1, 2> v7
  }

  bb 1 (preds 0) {
    Snapshot
    v8:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    Branch<2>
  }

  bb 2 (preds 0, 1) {
    v11:OptImmortalLongExact = Phi<0, 1> v5 v8
    Snapshot
    v12:ImmortalLongExact = CheckVar<"y"> v11 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v4 v11
      }
    }
    Return v12
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v4:Object = LoadArg<0; "x">
    v5:Nullptr = LoadConst<Nullptr>
    Snapshot
    v7:CInt32 = IsTruthy v4 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v4 v5
      }
    }
    CondBranch<1, 2> v7
  }

  bb 1 (preds 0) {
    Snapshot
    v8:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    Branch<2>
  }

  bb 2 (preds 0, 1) {
    v11:OptImmortalLongExact = Phi<0, 1> v5 v8
    Snapshot
    v12:ImmortalLongExact = CheckVar<"y"> v11 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v4 v11
      }
    }
    Return v12
  }
}
--- Test Name ---
VariablesAreUncheckedIfAssignedOnAllFlows
--- Input ---
def test(x):
  if x:
    y = 1
  else:
    y = 2
  return y
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v5:Object = LoadArg<0; "x">
    v6:Nullptr = LoadConst<Nullptr>
    Snapshot
    v8:CInt32 = IsTruthy v5 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v5 v6
      }
    }
    CondBranch<1, 2> v8
  }

  bb 1 (preds 0) {
    Snapshot
    v9:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    Return v9
  }

  bb 2 (preds 0) {
    Snapshot
    v12:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    Return v12
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v8:Object = LoadArg<0; "x">
    v9:Func = LoadCurrentFunc
    v10:Nullptr = LoadConst<Nullptr>
    Snapshot
    v11:CInt32 = LoadEvalBreaker
    CondBranch<4, 3> v11
  }

  bb 4 (preds 0) {
    Snapshot
    v12:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v8 v10
      }
    }
    Branch<3>
  }

  bb 3 (preds 0, 4) {
    Snapshot
    v16:CInt32 = IsTruthy v8 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v8 v10
      }
    }
    CondBranch<1, 2> v16
  }

  bb 1 (preds 3) {
    Snapshot
    v17:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    Return v17
  }

  bb 2 (preds 3) {
    Snapshot
    v20:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    Return v20
  }
}
--- Test Name ---
VariablesAreUncheckedOnSubgraphsWhereAssigned
--- Input ---
def test(x):
  if x:
    y = 1
    if x:
      return 100
  return y
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v6:Object = LoadArg<0; "x">
    v7:Nullptr = LoadConst<Nullptr>
    Snapshot
    v9:CInt32 = IsTruthy v6 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v6 v7
      }
    }
    CondBranch<1, 3> v9
  }

  bb 1 (preds 0) {
    Snapshot
    v10:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v13:CInt32 = IsTruthy v6 {
      FrameState {
        NextInstrOffset 12
        Locals<2> v6 v10
      }
    }
    CondBranch<2, 3> v13
  }

  bb 2 (preds 1) {
    Snapshot
    v14:ImmortalLongExact[100] = LoadConst<ImmortalLongExact[100]>
    Return v14
  }

  bb 3 (preds 0, 1) {
    v16:OptImmortalLongExact = Phi<0, 1> v7 v10
    Snapshot
    v17:ImmortalLongExact = CheckVar<"y"> v16 {
      FrameState {
        NextInstrOffset 18
        Locals<2> v6 v16
      }
    }
    Return v17
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v6:Object = LoadArg<0; "x">
    v7:Nullptr = LoadConst<Nullptr>
    Snapshot
    v9:CInt32 = IsTruthy v6 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v6 v7
      }
    }
    CondBranch<1, 3> v9
  }

  bb 1 (preds 0) {
    Snapshot
    v10:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v13:CInt32 = IsTruthy v6 {
      FrameState {
        NextInstrOffset 12
        Locals<2> v6 v10
      }
    }
    CondBranch<2, 3> v13
  }

  bb 2 (preds 1) {
    Snapshot
    v14:ImmortalLongExact[100] = LoadConst<ImmortalLongExact[100]>
    Return v14
  }

  bb 3 (preds 0, 1) {
    v16:OptImmortalLongExact = Phi<0, 1> v7 v10
    Snapshot
    v17:ImmortalLongExact = CheckVar<"y"> v16 {
      FrameState {
        NextInstrOffset 18
        Locals<2> v6 v16
      }
    }
    Return v17
  }
}
--- Test Name ---
BinaryOpSubscriptFromListIsSpecialized
--- Input ---
def test():
  ls = [1, 2, 3]
  return ls[1]
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v6:Nullptr = LoadConst<Nullptr>
    Snapshot
    v7:MortalListExact = MakeList<0> {
      FrameState {
        NextInstrOffset 2
        Locals<1> v6
      }
    }
    Snapshot
    v8:MortalTupleExact[tuple:0xdeadbeef] = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    v9:NoneType = ListExtend v7 v8 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v6
        Stack<1> v7
      }
    }
    Snapshot
    v12:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    UseType<ListExact> v7
    UseType<LongExact> v12
    v19:CInt64[1] = LoadConst<CInt64[1]>
    v20:CInt64[0] = LoadConst<CInt64[0]>
    v16:CInt64 = CheckSequenceBounds v7 v19 {
      FrameState {
        NextInstrOffset 14
        Locals<1> v7
      }
    }
    v17:CPtr = LoadField<ob_item@24, CPtr, borrowed> v7
    v18:Object = LoadArrayItem v17 v16 v7
    Snapshot
    Return v18
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v9:Func = LoadCurrentFunc
    v10:Nullptr = LoadConst<Nullptr>
    Snapshot
    v11:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v11
  }

  bb 2 (preds 0) {
    Snapshot
    v12:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<1> v10
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v14:MortalListExact = MakeList<0> {
      FrameState {
        NextInstrOffset 4
        Locals<1> v10
      }
    }
    Snapshot
    v15:MortalTupleExact[tuple:0xdeadbeef] = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    v16:NoneType = ListExtend v14 v15 {
      FrameState {
        NextInstrOffset 8
        Locals<1> v10
        Stack<1> v14
      }
    }
    Snapshot
    v19:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    UseType<ListExact> v14
    UseType<LongExact> v19
    v26:CInt64[1] = LoadConst<CInt64[1]>
    v27:CInt64[0] = LoadConst<CInt64[0]>
    v23:CInt64 = CheckSequenceBounds v14 v26 {
      FrameState {
        NextInstrOffset 16
        Locals<1> v14
      }
    }
    v24:CPtr = LoadField<ob_item@24, CPtr, borrowed> v14
    v25:Object = LoadArrayItem v24 v23 v14
    Snapshot
    Return v25
  }
}
--- Test Name ---
BinaryOpSubscriptFromNonListEmitsBinaryOp
--- Input ---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0>
    v1 = LoadConst<LongExact[1]>
    v2 = BinaryOp<Subscript> v0 v1
    Return v2
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v2:Object = BinaryOp<Subscript> v0 v1 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v2
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v2:Object = BinaryOp<Subscript> v0 v1 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v2
  }
}
--- Test Name ---
BinaryOpSubscriptFromTupleIsSpecialized
--- Input ---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0>
    v1 = LoadArg<1>
    v2 = RefineType<TupleExact> v0
    v3 = RefineType<LongExact> v1
    v4 = BinaryOp<Subscript> v2 v3
    Return v4
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:Object = LoadArg<1>
    v2:TupleExact = RefineType<TupleExact> v0
    v3:LongExact = RefineType<LongExact> v1
    UseType<TupleExact> v2
    UseType<LongExact> v3
    v5:CInt64 = IndexUnbox<IndexError> v3
    v6:CInt64 = IsNegativeAndErrOccurred v5 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v7:CInt64 = CheckSequenceBounds v2 v5 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v8:Object = LoadArrayItem<Offset[24]> v2 v7 v2
    Return v8
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:Object = LoadArg<1>
    v2:TupleExact = RefineType<TupleExact> v0
    v3:LongExact = RefineType<LongExact> v1
    UseType<TupleExact> v2
    UseType<LongExact> v3
    v5:CInt64 = IndexUnbox<IndexError> v3
    v6:CInt64 = IsNegativeAndErrOccurred v5 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v7:CInt64 = CheckSequenceBounds v2 v5 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v8:Object = LoadArrayItem<Offset[24]> v2 v7 v2
    Return v8
  }
}
--- Test Name ---
BinaryOpSubscriptConstStringConstLong
--- Input ---
def test():
  s = "foobar"
  i = 3
  return s[i]
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v5:Nullptr = LoadConst<Nullptr>
    Snapshot
    v6:MortalUnicodeExact["foobar"] = LoadConst<MortalUnicodeExact["foobar"]>
    v8:ImmortalLongExact[3] = LoadConst<ImmortalLongExact[3]>
    UseType<MortalUnicodeExact["foobar"]> v6
    UseType<ImmortalLongExact[3]> v8
    v13:MortalUnicodeExact["b"] = LoadConst<MortalUnicodeExact["b"]>
    Snapshot
    Return v13
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v8:Func = LoadCurrentFunc
    v9:Nullptr = LoadConst<Nullptr>
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v9 v9
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v14:ImmortalUnicodeExact["foobar"] = LoadConst<ImmortalUnicodeExact["foobar"]>
    v16:ImmortalLongExact[3] = LoadConst<ImmortalLongExact[3]>
    UseType<ImmortalUnicodeExact["foobar"]> v14
    UseType<ImmortalLongExact[3]> v16
    v21:ImmortalUnicodeExact["b"] = LoadConst<ImmortalUnicodeExact["b"]>
    Snapshot
    Return v21
  }
}
--- Test Name ---
BinaryOpSubscriptConstStringConstNegativeLong
--- Input ---
def test():
  s = "foobar"
  i = -2
  return s[i]
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v5:Nullptr = LoadConst<Nullptr>
    Snapshot
    v6:MortalUnicodeExact["foobar"] = LoadConst<MortalUnicodeExact["foobar"]>
    v8:ImmortalLongExact[-2] = LoadConst<ImmortalLongExact[-2]>
    UseType<MortalUnicodeExact["foobar"]> v6
    UseType<ImmortalLongExact[-2]> v8
    v13:MortalUnicodeExact["a"] = LoadConst<MortalUnicodeExact["a"]>
    Snapshot
    Return v13
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v8:Func = LoadCurrentFunc
    v9:Nullptr = LoadConst<Nullptr>
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v9 v9
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v14:ImmortalUnicodeExact["foobar"] = LoadConst<ImmortalUnicodeExact["foobar"]>
    v16:ImmortalLongExact[-2] = LoadConst<ImmortalLongExact[-2]>
    UseType<ImmortalUnicodeExact["foobar"]> v14
    UseType<ImmortalLongExact[-2]> v16
    v21:ImmortalUnicodeExact["a"] = LoadConst<ImmortalUnicodeExact["a"]>
    Snapshot
    Return v21
  }
}
--- Test Name ---
BinaryOpSubscriptConstStringConstOutOfBoundsLong
--- Input ---
def test():
  s = "foobar"
  i = 6
  return s[i]
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v5:Nullptr = LoadConst<Nullptr>
    Snapshot
    v6:MortalUnicodeExact["foobar"] = LoadConst<MortalUnicodeExact["foobar"]>
    v8:ImmortalLongExact[6] = LoadConst<ImmortalLongExact[6]>
    v12:Object = BinaryOp<Subscript> v6 v8 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v6 v8
      }
    }
    Snapshot
    Return v12
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v8:Func = LoadCurrentFunc
    v9:Nullptr = LoadConst<Nullptr>
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v9 v9
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v14:ImmortalUnicodeExact["foobar"] = LoadConst<ImmortalUnicodeExact["foobar"]>
    v16:ImmortalLongExact[6] = LoadConst<ImmortalLongExact[6]>
    v20:Object = BinaryOp<Subscript> v14 v16 {
      FrameState {
        NextInstrOffset 16
        Locals<2> v14 v16
      }
    }
    Snapshot
    Return v20
  }
}
--- Test Name ---
BinaryOpSubscriptConstStringConstNegativeOutOfBoundsLong
--- Input ---
def test():
  s = "foobar"
  i = -7
  return s[i]
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v5:Nullptr = LoadConst<Nullptr>
    Snapshot
    v6:MortalUnicodeExact["foobar"] = LoadConst<MortalUnicodeExact["foobar"]>
    v8:MortalLongExact[-7] = LoadConst<MortalLongExact[-7]>
    v12:Object = BinaryOp<Subscript> v6 v8 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v6 v8
      }
    }
    Snapshot
    Return v12
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v8:Func = LoadCurrentFunc
    v9:Nullptr = LoadConst<Nullptr>
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v9 v9
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v14:ImmortalUnicodeExact["foobar"] = LoadConst<ImmortalUnicodeExact["foobar"]>
    v16:MortalLongExact[-7] = LoadConst<MortalLongExact[-7]>
    v20:Object = BinaryOp<Subscript> v14 v16 {
      FrameState {
        NextInstrOffset 16
        Locals<2> v14 v16
      }
    }
    Snapshot
    Return v20
  }
}
--- Test Name ---
BinaryOpSubscriptUnicodeSubscr
--- Input ---
import os

def test():
    local_str = "foobar" if os.argv else "thudgrunt"
    local_int = 3 if os.argv else 5
    return local_str[local_int]
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v13:Nullptr = LoadConst<Nullptr>
    Snapshot
    v14:OptObject = LoadGlobalCached<0; "os">
    v15:MortalObjectUser[module:0xdeadbeef] = GuardIs<0xdeadbeef> v14 {
      Descr 'LOAD_GLOBAL: os'
    }
    Snapshot
    v41:Object = LoadAttrCached<1; "argv"> v15 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v13 v13
      }
    }
    Snapshot
    v17:CInt32 = IsTruthy v41 {
      FrameState {
        NextInstrOffset 6
        Locals<2> v13 v13
      }
    }
    CondBranch<1, 2> v17
  }

  bb 1 (preds 0) {
    Snapshot
    v18:MortalUnicodeExact["foobar"] = LoadConst<MortalUnicodeExact["foobar"]>
    Branch<3>
  }

  bb 2 (preds 0) {
    Snapshot
    v20:MortalUnicodeExact["thudgrunt"] = LoadConst<MortalUnicodeExact["thudgrunt"]>
    Branch<3>
  }

  bb 3 (preds 1, 2) {
    v22:MortalUnicodeExact = Phi<1, 2> v18 v20
    Snapshot
    v26:OptObject = LoadGlobalCached<0; "os">
    v27:MortalObjectUser[module:0xdeadbeef] = GuardIs<0xdeadbeef> v26 {
      Descr 'LOAD_GLOBAL: os'
    }
    Snapshot
    v42:Object = LoadAttrCached<1; "argv"> v27 {
      FrameState {
        NextInstrOffset 18
        Locals<2> v22 v13
      }
    }
    Snapshot
    v29:CInt32 = IsTruthy v42 {
      FrameState {
        NextInstrOffset 20
        Locals<2> v22 v13
      }
    }
    CondBranch<4, 5> v29
  }

  bb 4 (preds 3) {
    Snapshot
    v30:ImmortalLongExact[3] = LoadConst<ImmortalLongExact[3]>
    Branch<6>
  }

  bb 5 (preds 3) {
    Snapshot
    v32:ImmortalLongExact[5] = LoadConst<ImmortalLongExact[5]>
    Branch<6>
  }

  bb 6 (preds 4, 5) {
    v34:ImmortalLongExact = Phi<4, 5> v30 v32
    Snapshot
    UseType<UnicodeExact> v22
    UseType<LongExact> v34
    v43:CInt64 = IndexUnbox<IndexError> v34
    v44:CInt64 = IsNegativeAndErrOccurred v43 {
      FrameState {
        NextInstrOffset 34
        Locals<2> v22 v34
      }
    }
    v45:CInt64 = CheckSequenceBounds v22 v43 {
      FrameState {
        NextInstrOffset 34
        Locals<2> v22 v34
      }
    }
    v46:UnicodeExact = UnicodeSubscr v22 v45 {
      FrameState {
        NextInstrOffset 34
        Locals<2> v22 v34
      }
    }
    Snapshot
    Return v46
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v16:Func = LoadCurrentFunc
    v17:Nullptr = LoadConst<Nullptr>
    Snapshot
    v18:CInt32 = LoadEvalBreaker
    CondBranch<8, 7> v18
  }

  bb 8 (preds 0) {
    Snapshot
    v19:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v17 v17
      }
    }
    Branch<7>
  }

  bb 7 (preds 0, 8) {
    Snapshot
    v22:OptObject = LoadGlobalCached<0; "os">
    v23:MortalObjectUser[module:0xdeadbeef] = GuardIs<0xdeadbeef> v22 {
      Descr 'LOAD_GLOBAL: os'
    }
    Snapshot
    v54:Object = LoadAttrCached<1; "argv"> v23 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v17 v17
      }
    }
    Snapshot
    v25:CInt32 = IsTruthy v54 {
      FrameState {
        NextInstrOffset 34
        Locals<2> v17 v17
      }
    }
    CondBranch<1, 2> v25
  }

  bb 1 (preds 7) {
    Snapshot
    v26:ImmortalUnicodeExact["foobar"] = LoadConst<ImmortalUnicodeExact["foobar"]>
    Branch<3>
  }

  bb 2 (preds 7) {
    Snapshot
    v28:ImmortalUnicodeExact["thudgrunt"] = LoadConst<ImmortalUnicodeExact["thudgrunt"]>
    Branch<3>
  }

  bb 3 (preds 1, 2) {
    v30:ImmortalUnicodeExact = Phi<1, 2> v26 v28
    Snapshot
    v34:OptObject = LoadGlobalCached<0; "os">
    v35:MortalObjectUser[module:0xdeadbeef] = GuardIs<0xdeadbeef> v34 {
      Descr 'LOAD_GLOBAL: os'
    }
    Snapshot
    v49:Object = LoadAttrCached<1; "argv"> v35 {
      FrameState {
        NextInstrOffset 54
        Locals<2> v30 v17
      }
    }
    Snapshot
    v37:CInt32 = IsTruthy v49 {
      FrameState {
        NextInstrOffset 74
        Locals<2> v30 v17
      }
    }
    CondBranch<4, 5> v37
  }

  bb 4 (preds 3) {
    Snapshot
    v38:ImmortalLongExact[3] = LoadConst<ImmortalLongExact[3]>
    Branch<6>
  }

  bb 5 (preds 3) {
    Snapshot
    v40:ImmortalLongExact[5] = LoadConst<ImmortalLongExact[5]>
    Branch<6>
  }

  bb 6 (preds 4, 5) {
    v42:ImmortalLongExact = Phi<4, 5> v38 v40
    Snapshot
    UseType<UnicodeExact> v30
    UseType<LongExact> v42
    v50:CInt64 = IndexUnbox<IndexError> v42
    v51:CInt64 = IsNegativeAndErrOccurred v50 {
      FrameState {
        NextInstrOffset 88
        Locals<2> v30 v42
      }
    }
    v52:CInt64 = CheckSequenceBounds v30 v50 {
      FrameState {
        NextInstrOffset 88
        Locals<2> v30 v42
      }
    }
    v53:UnicodeExact = UnicodeSubscr v30 v52 {
      FrameState {
        NextInstrOffset 88
        Locals<2> v30 v42
      }
    }
    Snapshot
    Return v53
  }
}
--- Test Name ---
CondBranchOfIsTruthyWithNoneRemovesCondBranch
--- Input ---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0>
    v1 = RefineType<NoneType> v0
    v2 = IsTruthy v1
    CondBranch<1, 2> v2
  }

  bb 1 {
    Return v1
  }

  bb 2 {
    Return v1
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:NoneType = RefineType<NoneType> v0
    UseType<NoneType> v1
    v3:CInt32[0] = LoadConst<CInt32[0]>
    Return v1
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:NoneType = RefineType<NoneType> v0
    UseType<NoneType> v1
    v3:CInt32[0] = LoadConst<CInt32[0]>
    Return v1
  }
}
--- Test Name ---
CondBranchOfIsTruthyWithNoneDeletesUnreachableBlock
--- Input ---
def test():
  x = None
  y = True
  if not x:
    y = False
  else:
    y = True
  return y
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v7:Nullptr = LoadConst<Nullptr>
    Snapshot
    v8:NoneType = LoadConst<NoneType>
    v10:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<NoneType> v8
    v20:CInt32[0] = LoadConst<CInt32[0]>
    Snapshot
    v17:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v17
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v10:Func = LoadCurrentFunc
    v11:Nullptr = LoadConst<Nullptr>
    Snapshot
    v12:CInt32 = LoadEvalBreaker
    CondBranch<4, 3> v12
  }

  bb 4 (preds 0) {
    Snapshot
    v13:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v11 v11
      }
    }
    Branch<3>
  }

  bb 3 (preds 0, 4) {
    Snapshot
    v16:NoneType = LoadConst<NoneType>
    v18:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<NoneType> v16
    v28:CInt32[0] = LoadConst<CInt32[0]>
    Snapshot
    v25:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v25
  }
}
--- Test Name ---
CondBranchOfIsTruthyWithTrueDeletesUnreachableBlock
--- Input ---
def test():
  x = True
  y = True
  if not x:
    y = False
  else:
    y = True
  return y
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v7:Nullptr = LoadConst<Nullptr>
    Snapshot
    v8:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    v10:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<ImmortalBool[True]> v8
    v20:CInt32[1] = LoadConst<CInt32[1]>
    Snapshot
    v14:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v14
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v10:Func = LoadCurrentFunc
    v11:Nullptr = LoadConst<Nullptr>
    Snapshot
    v12:CInt32 = LoadEvalBreaker
    CondBranch<4, 3> v12
  }

  bb 4 (preds 0) {
    Snapshot
    v13:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v11 v11
      }
    }
    Branch<3>
  }

  bb 3 (preds 0, 4) {
    Snapshot
    v16:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    v18:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<ImmortalBool[True]> v16
    v28:CInt32[1] = LoadConst<CInt32[1]>
    Snapshot
    v22:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v22
  }
}
--- Test Name ---
IsTruthyWithZeroTurnsToFalse
--- Input ---
def test():
  x = 0
  y = True
  if not x:
    y = False
  return y
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v6:Nullptr = LoadConst<Nullptr>
    Snapshot
    v7:ImmortalLongExact[0] = LoadConst<ImmortalLongExact[0]>
    v9:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<ImmortalLongExact[0]> v7
    v18:CInt32[0] = LoadConst<CInt32[0]>
    Snapshot
    v13:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Snapshot
    Return v13
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v9:Func = LoadCurrentFunc
    v10:Nullptr = LoadConst<Nullptr>
    Snapshot
    v11:CInt32 = LoadEvalBreaker
    CondBranch<4, 3> v11
  }

  bb 4 (preds 0) {
    Snapshot
    v12:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v10 v10
      }
    }
    Branch<3>
  }

  bb 3 (preds 0, 4) {
    Snapshot
    v15:ImmortalLongExact[0] = LoadConst<ImmortalLongExact[0]>
    v17:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<ImmortalLongExact[0]> v15
    v26:CInt32[0] = LoadConst<CInt32[0]>
    Snapshot
    v21:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Snapshot
    Return v21
  }
}
--- Test Name ---
IsTruthyWithOneTurnsToTrue
--- Input ---
def test():
  x = 1
  y = True
  if not x:
    y = False
  return y
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v6:Nullptr = LoadConst<Nullptr>
    Snapshot
    v7:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v9:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<ImmortalLongExact[1]> v7
    v18:CInt32[1] = LoadConst<CInt32[1]>
    Snapshot
    Return v9
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v9:Func = LoadCurrentFunc
    v10:Nullptr = LoadConst<Nullptr>
    Snapshot
    v11:CInt32 = LoadEvalBreaker
    CondBranch<4, 3> v11
  }

  bb 4 (preds 0) {
    Snapshot
    v12:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v10 v10
      }
    }
    Branch<3>
  }

  bb 3 (preds 0, 4) {
    Snapshot
    v15:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v17:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<ImmortalLongExact[1]> v15
    v26:CInt32[1] = LoadConst<CInt32[1]>
    Snapshot
    Return v17
  }
}
--- Test Name ---
IsTruthyWithEmptyStringTurnsToFalse
--- Input ---
def test():
  x = ""
  y = True
  if not x:
    y = False
  return y
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v6:Nullptr = LoadConst<Nullptr>
    Snapshot
    v7:MortalUnicodeExact[""] = LoadConst<MortalUnicodeExact[""]>
    v9:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<MortalUnicodeExact[""]> v7
    v18:CInt32[0] = LoadConst<CInt32[0]>
    Snapshot
    v13:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Snapshot
    Return v13
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v9:Func = LoadCurrentFunc
    v10:Nullptr = LoadConst<Nullptr>
    Snapshot
    v11:CInt32 = LoadEvalBreaker
    CondBranch<4, 3> v11
  }

  bb 4 (preds 0) {
    Snapshot
    v12:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v10 v10
      }
    }
    Branch<3>
  }

  bb 3 (preds 0, 4) {
    Snapshot
    v15:ImmortalUnicodeExact[""] = LoadConst<ImmortalUnicodeExact[""]>
    v17:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<ImmortalUnicodeExact[""]> v15
    v26:CInt32[0] = LoadConst<CInt32[0]>
    Snapshot
    v21:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Snapshot
    Return v21
  }
}
--- Test Name ---
IsTruthyWithNonEmptyStringTurnsToTrue
--- Input ---
def test():
  x = "hello"
  y = True
  if not x:
    y = False
  return y
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v6:Nullptr = LoadConst<Nullptr>
    Snapshot
    v7:MortalUnicodeExact["hello"] = LoadConst<MortalUnicodeExact["hello"]>
    v9:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<MortalUnicodeExact["hello"]> v7
    v18:CInt32[1] = LoadConst<CInt32[1]>
    Snapshot
    Return v9
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v9:Func = LoadCurrentFunc
    v10:Nullptr = LoadConst<Nullptr>
    Snapshot
    v11:CInt32 = LoadEvalBreaker
    CondBranch<4, 3> v11
  }

  bb 4 (preds 0) {
    Snapshot
    v12:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v10 v10
      }
    }
    Branch<3>
  }

  bb 3 (preds 0, 4) {
    Snapshot
    v15:ImmortalUnicodeExact["hello"] = LoadConst<ImmortalUnicodeExact["hello"]>
    v17:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<ImmortalUnicodeExact["hello"]> v15
    v26:CInt32[1] = LoadConst<CInt32[1]>
    Snapshot
    Return v17
  }
}
--- Test Name ---
LoadAttrFromTypeIsSpecialized
--- Input ---
class Foo:
  pass

def test():
  return Foo.bar
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v2:OptObject = LoadGlobalCached<0; "Foo">
    v3:MortalTypeExact[Foo:obj] = GuardIs<0xdeadbeef> v2 {
      Descr 'LOAD_GLOBAL: Foo'
    }
    Snapshot
    UseType<Type> v3
    v5:OptObject = LoadTypeAttrCacheItem<0, 0>
    v6:CBool = PrimitiveCompare<Equal> v5 v3
    CondBranch<1, 2> v6
  }

  bb 1 (preds 0) {
    v7:Object = LoadTypeAttrCacheItem<0, 1>
    Branch<3>
  }

  bb 2 (preds 0) {
    v8:Object = FillTypeAttrCache<0, 1> v3 {
      FrameState {
        NextInstrOffset 4
      }
    }
    Branch<3>
  }

  bb 3 (preds 1, 2) {
    v9:Object = Phi<1, 2> v7 v8
    Snapshot
    Return v9
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v5:Func = LoadCurrentFunc
    Snapshot
    v6:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v6
  }

  bb 2 (preds 0) {
    Snapshot
    v7:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v8:OptObject = LoadGlobalCached<0; "Foo">
    v9:MortalTypeExact[Foo:obj] = GuardIs<0xdeadbeef> v8 {
      Descr 'LOAD_GLOBAL: Foo'
    }
    Snapshot
    UseType<Type> v9
    v11:OptObject = LoadTypeAttrCacheItem<0, 0>
    v12:CBool = PrimitiveCompare<Equal> v11 v9
    CondBranch<3, 4> v12
  }

  bb 3 (preds 1) {
    v13:Object = LoadTypeAttrCacheItem<0, 1>
    Branch<5>
  }

  bb 4 (preds 1) {
    v14:Object = FillTypeAttrCache<0, 1> v9 {
      FrameState {
        NextInstrOffset 14
      }
    }
    Branch<5>
  }

  bb 5 (preds 3, 4) {
    v15:Object = Phi<3, 4> v13 v14
    Snapshot
    Return v15
  }
}
--- Test Name ---
LoadAttrFromBuiltinTypeIsSpecialized
--- Input ---
def test():
  return int.__add__
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v2:OptObject = LoadGlobalCached<0; "int">
    v3:ImmortalTypeExact[int:obj] = GuardIs<0xdeadbeef> v2 {
      Descr 'LOAD_GLOBAL: int'
    }
    Snapshot
    UseType<Type> v3
    v5:OptObject = LoadTypeAttrCacheItem<0, 0>
    v6:CBool = PrimitiveCompare<Equal> v5 v3
    CondBranch<1, 2> v6
  }

  bb 1 (preds 0) {
    v7:Object = LoadTypeAttrCacheItem<0, 1>
    Branch<3>
  }

  bb 2 (preds 0) {
    v8:Object = FillTypeAttrCache<0, 1> v3 {
      FrameState {
        NextInstrOffset 4
      }
    }
    Branch<3>
  }

  bb 3 (preds 1, 2) {
    v9:Object = Phi<1, 2> v7 v8
    Snapshot
    Return v9
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v5:Func = LoadCurrentFunc
    Snapshot
    v6:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v6
  }

  bb 2 (preds 0) {
    Snapshot
    v7:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v8:OptObject = LoadGlobalCached<0; "int">
    v9:ImmortalTypeExact[int:obj] = GuardIs<0xdeadbeef> v8 {
      Descr 'LOAD_GLOBAL: int'
    }
    Snapshot
    UseType<Type> v9
    v11:OptObject = LoadTypeAttrCacheItem<0, 0>
    v12:CBool = PrimitiveCompare<Equal> v11 v9
    CondBranch<3, 4> v12
  }

  bb 3 (preds 1) {
    v13:Object = LoadTypeAttrCacheItem<0, 1>
    Branch<5>
  }

  bb 4 (preds 1) {
    v14:Object = FillTypeAttrCache<0, 1> v9 {
      FrameState {
        NextInstrOffset 14
      }
    }
    Branch<5>
  }

  bb 5 (preds 3, 4) {
    v15:Object = Phi<3, 4> v13 v14
    Snapshot
    Return v15
  }
}
--- Test Name ---
LoadAttrFromModuleIsUnspecialized
--- Input ---
import sys

def test():
  return sys.path
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v2:OptObject = LoadGlobalCached<0; "sys">
    v3:MortalObjectUser[module:0xdeadbeef] = GuardIs<0xdeadbeef> v2 {
      Descr 'LOAD_GLOBAL: sys'
    }
    Snapshot
    v5:Object = LoadAttrCached<1; "path"> v3 {
      FrameState {
        NextInstrOffset 4
      }
    }
    Snapshot
    Return v5
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v5:Func = LoadCurrentFunc
    Snapshot
    v6:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v6
  }

  bb 2 (preds 0) {
    Snapshot
    v7:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v8:OptObject = LoadGlobalCached<0; "sys">
    v9:MortalObjectUser[module:0xdeadbeef] = GuardIs<0xdeadbeef> v8 {
      Descr 'LOAD_GLOBAL: sys'
    }
    Snapshot
    v11:Object = LoadAttrCached<1; "path"> v9 {
      FrameState {
        NextInstrOffset 14
      }
    }
    Snapshot
    Return v11
  }
}
--- Test Name ---
RedundantGuardTypeIsRemoved
--- Input ---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<TupleExact> v1
    v3 = GuardType<Tuple> v2
    Return v3
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:TupleExact = RefineType<TupleExact> v1
    Return v2
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:TupleExact = RefineType<TupleExact> v1
    Return v2
  }
}
--- Test Name ---
CompareOfTwoNonesTurnsToLoadConst
--- Input ---
# HIR
fun test {
  bb 0 {
    v0:Object = LoadArg<0; "x">
    v1:Object = LoadConst<NoneType>
    v2:NoneType = GuardType<NoneType> v0
    v3:Object = Compare<Equal> v1 v2
    v4:CInt32 = IsTruthy v3 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v2 v1
      }
    }
    CondBranch<2, 1> v4
  }

  bb 1 (preds 0) {
    v5:NoneType = LoadConst<NoneType>
    Branch<2>
  }

  bb 2 (preds 0, 1) {
    v7:Object = Phi<0, 1> v1 v5
    Return v7
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:NoneType = LoadConst<NoneType>
    v8:NoneType = GuardIs<0xdeadbeef> v0 {
    }
    UseType<NoneType> v1
    UseType<NoneType> v8
    v9:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<ImmortalBool[True]> v9
    v10:CInt32[1] = LoadConst<CInt32[1]>
    Return v1
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:NoneType = LoadConst<NoneType>
    v8:NoneType = GuardIs<0xdeadbeef> v0 {
    }
    UseType<NoneType> v1
    UseType<NoneType> v8
    v9:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<ImmortalBool[True]> v9
    v10:CInt32[1] = LoadConst<CInt32[1]>
    Return v1
  }
}
--- Test Name ---
CompareIsOfNonEqualTypesTurnsToLoadConst
--- Input ---
def test():
  x = 2
  if x is None:
    return True
  return False
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v8:Nullptr = LoadConst<Nullptr>
    Snapshot
    v9:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v12:NoneType = LoadConst<NoneType>
    UseType<ImmortalLongExact[2]> v9
    UseType<NoneType> v12
    v18:CBool[false] = LoadConst<CBool[false]>
    UseType<CBool[false]> v18
    v19:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    UseType<ImmortalBool[False]> v19
    v20:CInt32[0] = LoadConst<CInt32[0]>
    Snapshot
    v17:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v17
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v8:Nullptr = LoadConst<Nullptr>
    Snapshot
    v9:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v12:NoneType = LoadConst<NoneType>
    UseType<ImmortalLongExact[2]> v9
    UseType<NoneType> v12
    v18:CBool[false] = LoadConst<CBool[false]>
    UseType<CBool[false]> v18
    v19:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    UseType<ImmortalBool[False]> v19
    v20:CInt32[0] = LoadConst<CInt32[0]>
    Snapshot
    v17:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v17
  }
}
--- Test Name ---
CompareIsOfKnownObjectsTurnsToLoadConst
--- Input ---
def test():
  x = 2
  y = 4
  if x is y:
    return True
  return False
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v9:Nullptr = LoadConst<Nullptr>
    Snapshot
    v10:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v12:ImmortalLongExact[4] = LoadConst<ImmortalLongExact[4]>
    UseType<ImmortalLongExact[2]> v10
    UseType<ImmortalLongExact[4]> v12
    v21:CBool[false] = LoadConst<CBool[false]>
    UseType<CBool[false]> v21
    v22:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    UseType<ImmortalBool[False]> v22
    v23:CInt32[0] = LoadConst<CInt32[0]>
    Snapshot
    v20:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v20
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v12:Func = LoadCurrentFunc
    v13:Nullptr = LoadConst<Nullptr>
    Snapshot
    v14:CInt32 = LoadEvalBreaker
    CondBranch<4, 3> v14
  }

  bb 4 (preds 0) {
    Snapshot
    v15:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v13 v13
      }
    }
    Branch<3>
  }

  bb 3 (preds 0, 4) {
    Snapshot
    v18:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v20:ImmortalLongExact[4] = LoadConst<ImmortalLongExact[4]>
    UseType<ImmortalLongExact[2]> v18
    UseType<ImmortalLongExact[4]> v20
    v31:CBool[false] = LoadConst<CBool[false]>
    UseType<CBool[false]> v31
    v32:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    UseType<ImmortalBool[False]> v32
    v33:CInt32[0] = LoadConst<CInt32[0]>
    Snapshot
    v29:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return<ImmortalBool[False]> v29
  }
}
--- Test Name ---
CompareOfTwoLongsTurnsToLongCompare
--- Input ---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    v2 = GuardType<LongExact> v0
    v3 = GuardType<LongExact> v1
    v4 = Compare<Equal> v2 v3
    v5 = IsTruthy v4 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v2 v3
      }
    }
    CondBranch<2, 1> v5
  }

  bb 1 (preds 0) {
    v6 = LoadConst<ImmortalBool[True]>
    Return v6
  }

  bb 2 (preds 0) {
    v7 = LoadConst<ImmortalBool[False]>
    Return v7
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:Object = LoadArg<1>
    v2:LongExact = GuardType<LongExact> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v3:LongExact = GuardType<LongExact> v1 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v8:Bool = LongCompare<Equal> v2 v3
    UseType<Bool> v8
    v9:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    v10:CBool = PrimitiveCompare<Equal> v8 v9
    v11:CInt32 = IntConvert<CInt32> v10
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    v7:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v7
  }

  bb 1 (preds 0) {
    v6:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v6
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:Object = LoadArg<1>
    v2:LongExact = GuardType<LongExact> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v3:LongExact = GuardType<LongExact> v1 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v8:Bool = LongCompare<Equal> v2 v3
    UseType<Bool> v8
    v9:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    v10:CBool = PrimitiveCompare<Equal> v8 v9
    v11:CInt32 = IntConvert<CInt32> v10
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    v7:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v7
  }

  bb 1 (preds 0) {
    v6:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v6
  }
}
--- Test Name ---
CompareOfTwoStringsTurnsToUnicodeCompare
--- Input ---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0; "x">
    v1 = LoadArg<1; "y">
    v2 = GuardType<UnicodeExact> v0
    v3 = GuardType<UnicodeExact> v1
    v4 = Compare<Equal> v2 v3
    v5 = IsTruthy v4 {
      FrameState {
        NextInstrOffset 4
        Locals<2> v2 v3
      }
    }
    CondBranch<2, 1> v5
  }

  bb 1 (preds 0) {
    v6 = LoadConst<ImmortalBool[True]>
    Return v6
  }

  bb 2 (preds 0) {
    v7 = LoadConst<ImmortalBool[False]>
    Return v7
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:Object = LoadArg<1>
    v2:UnicodeExact = GuardType<UnicodeExact> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v3:UnicodeExact = GuardType<UnicodeExact> v1 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v8:Bool = UnicodeCompare<Equal> v2 v3
    UseType<Bool> v8
    v9:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    v10:CBool = PrimitiveCompare<Equal> v8 v9
    v11:CInt32 = IntConvert<CInt32> v10
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    v7:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v7
  }

  bb 1 (preds 0) {
    v6:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v6
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:Object = LoadArg<1>
    v2:UnicodeExact = GuardType<UnicodeExact> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v3:UnicodeExact = GuardType<UnicodeExact> v1 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v8:Bool = UnicodeCompare<Equal> v2 v3
    UseType<Bool> v8
    v9:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    v10:CBool = PrimitiveCompare<Equal> v8 v9
    v11:CInt32 = IntConvert<CInt32> v10
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    v7:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v7
  }

  bb 1 (preds 0) {
    v6:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v6
  }
}
--- Test Name ---
CondBranchCheckTypeWithKnownTypeTransformsToBranch
--- Input ---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0>
    v1 = RefineType<TupleExact> v0
    CondBranchCheckType<1, 2, Tuple> v1
  }

  bb 1 {
    v2 = LoadConst<NoneType>
    Return v2
  }

  bb 2 {
    v3 = LoadConst<NoneType>
    Return v3
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:TupleExact = RefineType<TupleExact> v0
    UseType<TupleExact> v1
    v2:NoneType = LoadConst<NoneType>
    Return v2
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:TupleExact = RefineType<TupleExact> v0
    UseType<TupleExact> v1
    v2:NoneType = LoadConst<NoneType>
    Return v2
  }
}
--- Test Name ---
CondBranchCheckTypeWithKnownIncompatibleTypeTransformsToBranch
--- Input ---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0>
    v1 = RefineType<NoneType> v0
    CondBranchCheckType<1, 2, Tuple> v1
  }

  bb 1 {
    v2 = LoadConst<NoneType>
    Return v2
  }

  bb 2 {
    v3 = LoadConst<NoneType>
    Return v3
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:NoneType = RefineType<NoneType> v0
    UseType<NoneType> v1
    v3:NoneType = LoadConst<NoneType>
    Return v3
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:NoneType = RefineType<NoneType> v0
    UseType<NoneType> v1
    v3:NoneType = LoadConst<NoneType>
    Return v3
  }
}
--- Test Name ---
CondBranchCheckTypeWithNoTypeInformationDoesNotTransform
--- Input ---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0>
    CondBranchCheckType<1, 2, Tuple> v0
  }

  bb 1 {
    v2 = LoadConst<NoneType>
    Return v2
  }

  bb 2 {
    v3 = LoadConst<NoneType>
    Return v3
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    CondBranchCheckType<1, 2, Tuple> v0
  }

  bb 1 (preds 0) {
    v2:NoneType = LoadConst<NoneType>
    Return v2
  }

  bb 2 (preds 0) {
    v3:NoneType = LoadConst<NoneType>
    Return v3
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    CondBranchCheckType<1, 2, Tuple> v0
  }

  bb 1 (preds 0) {
    v2:NoneType = LoadConst<NoneType>
    Return v2
  }

  bb 2 (preds 0) {
    v3:NoneType = LoadConst<NoneType>
    Return v3
  }
}
--- Test Name ---
IsTruthyWithObjectRemainsIsTruthy
--- Input ---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = Assign v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = Assign v1
    v3:CInt32 = IsTruthy v2 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v4:LongExact = PrimitiveBox<CInt32> v3 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = Assign v1
    v3:CInt32 = IsTruthy v2 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v4:LongExact = PrimitiveBox<CInt32> v3 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Test Name ---
IsTruthyWithBoolRewritesToPrimitiveCompare
--- Input ---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<Bool> v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Bool = RefineType<Bool> v1
    UseType<Bool> v2
    v5:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    v6:CBool = PrimitiveCompare<Equal> v2 v5
    v7:CInt32 = IntConvert<CInt32> v6
    v4:LongExact = PrimitiveBox<CInt32> v7 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Bool = RefineType<Bool> v1
    UseType<Bool> v2
    v5:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    v6:CBool = PrimitiveCompare<Equal> v2 v5
    v7:CInt32 = IntConvert<CInt32> v6
    v4:LongExact = PrimitiveBox<CInt32> v7 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Test Name ---
IsTruthyWithListExactRewritesToLoadField
--- Input ---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<ListExact> v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:ListExact = RefineType<ListExact> v1
    UseType<ListExact> v2
    v5:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:ListExact = RefineType<ListExact> v1
    UseType<ListExact> v2
    v5:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Test Name ---
IsTruthyWithListExactWithObjSpecRewritesToLoadField
--- Input ---
a = [1,2,3]
def test():
  if a:
    return 1
  return 2
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v4:OptObject = LoadGlobalCached<0; "a">
    v5:MortalListExact[list:0xdeadbeef] = GuardIs<0xdeadbeef> v4 {
      Descr 'LOAD_GLOBAL: a'
    }
    Snapshot
    UseType<MortalListExact> v5
    v9:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v5
    v10:CInt32 = IntConvert<CInt32> v9
    CondBranch<1, 2> v10
  }

  bb 1 (preds 0) {
    Snapshot
    v7:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    Return v7
  }

  bb 2 (preds 0) {
    Snapshot
    v8:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    Return v8
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v7:Func = LoadCurrentFunc
    Snapshot
    v8:CInt32 = LoadEvalBreaker
    CondBranch<4, 3> v8
  }

  bb 4 (preds 0) {
    Snapshot
    v9:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
      }
    }
    Branch<3>
  }

  bb 3 (preds 0, 4) {
    Snapshot
    v10:OptObject = LoadGlobalCached<0; "a">
    v11:MortalListExact[list:0xdeadbeef] = GuardIs<0xdeadbeef> v10 {
      Descr 'LOAD_GLOBAL: a'
    }
    Snapshot
    UseType<MortalListExact> v11
    v17:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v11
    v18:CInt32 = IntConvert<CInt32> v17
    CondBranch<1, 2> v18
  }

  bb 1 (preds 3) {
    Snapshot
    v13:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    Return<ImmortalLongExact[1]> v13
  }

  bb 2 (preds 3) {
    Snapshot
    v15:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    Return<ImmortalLongExact[2]> v15
  }
}
--- Test Name ---
IsTruthyWithTupleExactRewritesToLoadField
--- Input ---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<TupleExact> v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:TupleExact = RefineType<TupleExact> v1
    UseType<TupleExact> v2
    v5:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:TupleExact = RefineType<TupleExact> v1
    UseType<TupleExact> v2
    v5:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Test Name ---
IsTruthyWithArrayExactRewritesToLoadField
--- Input ---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<Array> v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Array = RefineType<Array> v1
    UseType<Array> v2
    v5:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Array = RefineType<Array> v1
    UseType<Array> v2
    v5:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Test Name ---
IsTruthyWithDictExactRewritesToLoadField
--- Input ---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<DictExact> v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:DictExact = RefineType<DictExact> v1
    UseType<DictExact> v2
    v5:CInt64 = LoadField<ma_used@16, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:DictExact = RefineType<DictExact> v1
    UseType<DictExact> v2
    v5:CInt64 = LoadField<ma_used@16, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Test Name ---
IsTruthyWithSetExactRewritesToLoadField
--- Input ---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<SetExact> v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:SetExact = RefineType<SetExact> v1
    UseType<SetExact> v2
    v5:CInt64 = LoadField<used@24, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:SetExact = RefineType<SetExact> v1
    UseType<SetExact> v2
    v5:CInt64 = LoadField<used@24, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Test Name ---
IsTruthyWithUnicodeExactRewritesToLoadField
--- Input ---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<UnicodeExact> v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:UnicodeExact = RefineType<UnicodeExact> v1
    UseType<UnicodeExact> v2
    v5:CInt64 = LoadField<length@16, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:UnicodeExact = RefineType<UnicodeExact> v1
    UseType<UnicodeExact> v2
    v5:CInt64 = LoadField<length@16, CInt64, borrowed> v2
    v6:CInt32 = IntConvert<CInt32> v5
    v4:LongExact = PrimitiveBox<CInt32> v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Test Name ---
IsTruthyWithLongExactRewritesToPrimitiveCompare
--- Input ---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = RefineType<LongExact> v1
    v3 = IsTruthy v2
    v4 = PrimitiveBox<CInt32> v3
    Return v4
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:LongExact = RefineType<LongExact> v1
    UseType<LongExact> v2
    v5:ImmortalLongExact[0] = LoadConst<ImmortalLongExact[0]>
    v6:CBool = PrimitiveCompare<NotEqual> v2 v5
    v7:CInt32 = IntConvert<CInt32> v6
    v4:LongExact = PrimitiveBox<CInt32> v7 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:LongExact = RefineType<LongExact> v1
    UseType<LongExact> v2
    v5:ImmortalLongExact[0] = LoadConst<ImmortalLongExact[0]>
    v6:CBool = PrimitiveCompare<NotEqual> v2 v5
    v7:CInt32 = IntConvert<CInt32> v6
    v4:LongExact = PrimitiveBox<CInt32> v7 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Test Name ---
TypeIsTurnedIntoFieldLoad
--- Input ---
def test(x):
  return type(x)
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v3:Object = LoadArg<0; "x">
    Snapshot
    v4:OptObject = LoadGlobalCached<0; "type">
    v5:ImmortalTypeExact[type:obj] = GuardIs<0xdeadbeef> v4 {
      Descr 'LOAD_GLOBAL: type'
    }
    Snapshot
    UseType<ImmortalTypeExact[type:obj]> v5
    v8:Type = LoadField<ob_type@8, Type, borrowed> v3
    Snapshot
    Return v8
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v7:Object = LoadArg<0; "x">
    v8:Func = LoadCurrentFunc
    Snapshot
    v9:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v9
  }

  bb 2 (preds 0) {
    Snapshot
    v10:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<1> v7
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v12:Nullptr = LoadConst<Nullptr>
    v13:OptObject = LoadGlobalCached<0; "type">
    v14:ImmortalTypeExact[type:obj] = GuardIs<0xdeadbeef> v13 {
      Descr 'LOAD_GLOBAL: type'
    }
    Snapshot
    v16:Object = CallMethod<3> v12 v14 v7 {
      FrameState {
        NextInstrOffset 16
        Locals<1> v7
      }
    }
    Snapshot
    Return v16
  }
}
--- Test Name ---
BinaryOpWithLeftAndRightLongExactTurnsIntoLongBinaryOp
--- Input ---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<LongExact> v1
    v4 = RefineType<LongExact> v2
    v5 = BinaryOp<Add> v3 v4
    Return v5
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:LongExact = RefineType<LongExact> v1
    v4:LongExact = RefineType<LongExact> v2
    UseType<LongExact> v3
    UseType<LongExact> v4
    v6:LongExact = LongBinaryOp<Add> v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:LongExact = RefineType<LongExact> v1
    v4:LongExact = RefineType<LongExact> v2
    UseType<LongExact> v3
    UseType<LongExact> v4
    v6:LongExact = LongBinaryOp<Add> v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
--- Test Name ---
BinaryOpWithObjSpecLeftAndRightLongExactTurnsIntoLoadConst
--- Input ---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<LongExact[2]> v1
    v4 = RefineType<LongExact[3]> v2
    v5 = BinaryOp<Power> v3 v4
    Return v5
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:ImmortalLongExact[2] = RefineType<ImmortalLongExact[2]> v1
    v4:ImmortalLongExact[3] = RefineType<ImmortalLongExact[3]> v2
    UseType<LongExact> v3
    UseType<LongExact> v4
    UseType<ImmortalLongExact[2]> v3
    UseType<ImmortalLongExact[3]> v4
    v7:ImmortalLongExact[8] = LoadConst<ImmortalLongExact[8]>
    Return v7
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:ImmortalLongExact[2] = RefineType<ImmortalLongExact[2]> v1
    v4:ImmortalLongExact[3] = RefineType<ImmortalLongExact[3]> v2
    UseType<LongExact> v3
    UseType<LongExact> v4
    UseType<ImmortalLongExact[2]> v3
    UseType<ImmortalLongExact[3]> v4
    v7:ImmortalLongExact[8] = LoadConst<ImmortalLongExact[8]>
    Return v7
  }
}
--- Test Name ---
BinaryOpTrueDivideWithLeftAndRightLongExactTurnsIntoLongBinaryOpFloat
--- Input ---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<LongExact> v1
    v4 = RefineType<LongExact> v2
    v5 = BinaryOp<TrueDivide> v3 v4
    Return v5
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:LongExact = RefineType<LongExact> v1
    v4:LongExact = RefineType<LongExact> v2
    UseType<LongExact> v3
    UseType<LongExact> v4
    v6:FloatExact = LongBinaryOp<TrueDivide> v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:LongExact = RefineType<LongExact> v1
    v4:LongExact = RefineType<LongExact> v2
    UseType<LongExact> v3
    UseType<LongExact> v4
    v6:FloatExact = LongBinaryOp<TrueDivide> v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
--- Test Name ---
BinarySubscrWithConstTupleAndObjectSpecIndexSimplifiesToLoadConst
--- Input ---
def test():
  tup = (1,(2,3,4),5)
  return tup[1][2]
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v6:Nullptr = LoadConst<Nullptr>
    Snapshot
    v7:MortalTupleExact[tuple:0xdeadbeef] = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    v10:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v7
    UseType<ImmortalLongExact[1]> v10
    v14:MortalTupleExact[tuple:0xdeadbeef] = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    Snapshot
    v12:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v14
    UseType<ImmortalLongExact[2]> v12
    v15:ImmortalLongExact[4] = LoadConst<ImmortalLongExact[4]>
    Snapshot
    Return v15
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v9:Func = LoadCurrentFunc
    v10:Nullptr = LoadConst<Nullptr>
    Snapshot
    v11:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v11
  }

  bb 2 (preds 0) {
    Snapshot
    v12:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<1> v10
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v14:MortalTupleExact[tuple:0xdeadbeef] = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    v17:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v14
    UseType<ImmortalLongExact[1]> v17
    v21:MortalTupleExact[tuple:0xdeadbeef] = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    Snapshot
    v19:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v21
    UseType<ImmortalLongExact[2]> v19
    v22:ImmortalLongExact[4] = LoadConst<ImmortalLongExact[4]>
    Snapshot
    Return v22
  }
}
--- Test Name ---
IsBecomesComparisonOutsideIf
--- Input ---
def test(x, y):
  return x is y
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v4:Object = LoadArg<0; "x">
    v5:Object = LoadArg<1; "y">
    Snapshot
    v8:CBool = PrimitiveCompare<Equal> v4 v5
    v9:Bool = PrimitiveBoxBool v8
    Return v9
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v7:Object = LoadArg<0; "x">
    v8:Object = LoadArg<1; "y">
    v9:Func = LoadCurrentFunc
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v7 v8
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v16:CBool = PrimitiveCompare<Equal> v7 v8
    v17:Bool = PrimitiveBoxBool v16
    Return v17
  }
}
--- Test Name ---
IsNotBecomesComparisonOutsideIf
--- Input ---
def test(x, y):
  return x is not y
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v4:Object = LoadArg<0; "x">
    v5:Object = LoadArg<1; "y">
    Snapshot
    v8:CBool = PrimitiveCompare<NotEqual> v4 v5
    v9:Bool = PrimitiveBoxBool v8
    Return v9
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v7:Object = LoadArg<0; "x">
    v8:Object = LoadArg<1; "y">
    v9:Func = LoadCurrentFunc
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v7 v8
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v16:CBool = PrimitiveCompare<NotEqual> v7 v8
    v17:Bool = PrimitiveBoxBool v16
    Return v17
  }
}
--- Test Name ---
DontSpecializeLongSubscript
--- Input ---
# HIR
fun jittestmodule:test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<LongExact> v1
    v4 = RefineType<LongExact> v2
    v5 = BinaryOp<Subscript> v3 v4
    Return v5
  }
}
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:LongExact = RefineType<LongExact> v1
    v4:LongExact = RefineType<LongExact> v2
    v5:Object = BinaryOp<Subscript> v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v5
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:LongExact = RefineType<LongExact> v1
    v4:LongExact = RefineType<LongExact> v2
    v5:Object = BinaryOp<Subscript> v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v5
  }
}
--- Test Name ---
UnicodeConcatEmittedWhenWhenAddingString
--- Input ---
def test():
  x = "hello"
  y = " world"
  return x+y
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v5:Nullptr = LoadConst<Nullptr>
    Snapshot
    v6:MortalUnicodeExact["hello"] = LoadConst<MortalUnicodeExact["hello"]>
    v8:MortalUnicodeExact[" world"] = LoadConst<MortalUnicodeExact[" world"]>
    v13:UnicodeExact = UnicodeConcat v6 v8 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v6 v8
      }
    }
    Snapshot
    Return v13
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v8:Func = LoadCurrentFunc
    v9:Nullptr = LoadConst<Nullptr>
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v9 v9
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v14:ImmortalUnicodeExact["hello"] = LoadConst<ImmortalUnicodeExact["hello"]>
    v16:MortalUnicodeExact[" world"] = LoadConst<MortalUnicodeExact[" world"]>
    v21:UnicodeExact = UnicodeConcat v14 v16 {
      FrameState {
        NextInstrOffset 16
        Locals<2> v14 v16
      }
    }
    Snapshot
    Return v21
  }
}
--- Test Name ---
UnicodeConcatDoesNotEmitWhenStringAddingLong
--- Input ---
def test():
  x = "hello"
  y = 1
  return x+y
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v5:Nullptr = LoadConst<Nullptr>
    Snapshot
    v6:MortalUnicodeExact["hello"] = LoadConst<MortalUnicodeExact["hello"]>
    v8:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v12:Object = BinaryOp<Add> v6 v8 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v6 v8
      }
    }
    Snapshot
    Return v12
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v8:Func = LoadCurrentFunc
    v9:Nullptr = LoadConst<Nullptr>
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v9 v9
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v14:ImmortalUnicodeExact["hello"] = LoadConst<ImmortalUnicodeExact["hello"]>
    v16:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v20:Object = BinaryOp<Add> v14 v16 {
      FrameState {
        NextInstrOffset 16
        Locals<2> v14 v16
      }
    }
    Snapshot
    Return v20
  }
}
--- Test Name ---
UnicodeConcatEmittedWhenSimplyfingAddingTwoUnicode
--- Input ---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<UnicodeExact> v1
    v4 = RefineType<UnicodeExact> v2
    v5:UnicodeExact = BinaryOp<Add> v3 v4
    Return v5
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:UnicodeExact = RefineType<UnicodeExact> v1
    v4:UnicodeExact = RefineType<UnicodeExact> v2
    v6:UnicodeExact = UnicodeConcat v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:UnicodeExact = RefineType<UnicodeExact> v1
    v4:UnicodeExact = RefineType<UnicodeExact> v2
    v6:UnicodeExact = UnicodeConcat v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
--- Test Name ---
UnicodeRepeatEmittedWhenMultiplyingString
--- Input ---
def test():
  a = "abc"
  b = 2
  return a*b
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v5:Nullptr = LoadConst<Nullptr>
    Snapshot
    v6:MortalUnicodeExact["abc"] = LoadConst<MortalUnicodeExact["abc"]>
    v8:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v16:CInt64[2] = LoadConst<CInt64[2]>
    v17:CInt64[0] = LoadConst<CInt64[0]>
    v15:UnicodeExact = UnicodeRepeat v6 v16 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v6 v8
      }
    }
    Snapshot
    Return v15
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v8:Func = LoadCurrentFunc
    v9:Nullptr = LoadConst<Nullptr>
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v9 v9
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v14:ImmortalUnicodeExact["abc"] = LoadConst<ImmortalUnicodeExact["abc"]>
    v16:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v24:CInt64[2] = LoadConst<CInt64[2]>
    v25:CInt64[0] = LoadConst<CInt64[0]>
    v23:UnicodeExact = UnicodeRepeat v14 v24 {
      FrameState {
        NextInstrOffset 16
        Locals<2> v14 v16
      }
    }
    Snapshot
    Return v23
  }
}
--- Test Name ---
UnicodeRepeatDoesNotEmitWhenStringMultipliedByNonLongExact
--- Input ---
def test():
  a = "abc"
  b = True
  return a*b
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v5:Nullptr = LoadConst<Nullptr>
    Snapshot
    v6:MortalUnicodeExact["abc"] = LoadConst<MortalUnicodeExact["abc"]>
    v8:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    v12:Object = BinaryOp<Multiply> v6 v8 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v6 v8
      }
    }
    Snapshot
    Return v12
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v8:Func = LoadCurrentFunc
    v9:Nullptr = LoadConst<Nullptr>
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<2> v9 v9
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v14:ImmortalUnicodeExact["abc"] = LoadConst<ImmortalUnicodeExact["abc"]>
    v16:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    v20:Object = BinaryOp<Multiply> v14 v16 {
      FrameState {
        NextInstrOffset 16
        Locals<2> v14 v16
      }
    }
    Snapshot
    Return v20
  }
}
--- Test Name ---
UnicodeRepeatEmittedWhenSimplyfingMultiplyWithNonConstLongExact
--- Input ---
# HIR
fun test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<UnicodeExact> v1
    v4 = RefineType<LongExact> v2
    v5:UnicodeExact = BinaryOp<Multiply> v3 v4
    Return v5
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:UnicodeExact = RefineType<UnicodeExact> v1
    v4:LongExact = RefineType<LongExact> v2
    v6:CInt64 = IndexUnbox<OverflowError> v4
    v7:CInt64 = IsNegativeAndErrOccurred v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v8:UnicodeExact = UnicodeRepeat v3 v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v8
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:UnicodeExact = RefineType<UnicodeExact> v1
    v4:LongExact = RefineType<LongExact> v2
    v6:CInt64 = IndexUnbox<OverflowError> v4
    v7:CInt64 = IsNegativeAndErrOccurred v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v8:UnicodeExact = UnicodeRepeat v3 v6 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v8
  }
}
--- Test Name ---
BinarySubscrWithDictExactAndUnicodeExactEmitsDictSubscr
--- Input ---
# HIR
fun jittestmodule:test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<DictExact> v1
    v4 = RefineType<UnicodeExact> v2
    v5 = BinaryOp<Subscript> v3 v4
    Return v5
  }
}
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:DictExact = RefineType<DictExact> v1
    v4:UnicodeExact = RefineType<UnicodeExact> v2
    v6:Object = DictSubscr v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:DictExact = RefineType<DictExact> v1
    v4:UnicodeExact = RefineType<UnicodeExact> v2
    v6:Object = DictSubscr v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
--- Test Name ---
BinarySubscrWithDictExactAndLongExactEmitsDictSubscr
--- Input ---
# HIR
fun jittestmodule:test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<DictExact> v1
    v4 = RefineType<LongExact> v2
    v5 = BinaryOp<Subscript> v3 v4
    Return v5
  }
}
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:DictExact = RefineType<DictExact> v1
    v4:LongExact = RefineType<LongExact> v2
    v6:Object = DictSubscr v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:DictExact = RefineType<DictExact> v1
    v4:LongExact = RefineType<LongExact> v2
    v6:Object = DictSubscr v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
--- Test Name ---
BinarySubscrWithDictExactAndDictExactEmitsDictSubscr
--- Input ---
# HIR
fun jittestmodule:test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = LoadArg<1>
    v3 = RefineType<DictExact> v1
    v4 = RefineType<DictExact> v2
    v5 = BinaryOp<Subscript> v3 v4
    Return v5
  }
}
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:DictExact = RefineType<DictExact> v1
    v4:DictExact = RefineType<DictExact> v2
    v6:Object = DictSubscr v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:Object = LoadArg<1>
    v3:DictExact = RefineType<DictExact> v1
    v4:DictExact = RefineType<DictExact> v2
    v6:Object = DictSubscr v3 v4 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v6
  }
}
--- Test Name ---
GuardIsReturnsIntersectionOfInputAndTarget
--- Input ---
# HIR
fun jittestmodule:test {
  bb 0 {
    v1 = LoadArg<0>
    v2 = GuardType<LongExact> v1
    v3 = GuardType<NoneType> v2
    Return v3
  }
}
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:LongExact = GuardType<LongExact> v1 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v4:Bottom = GuardIs<0xdeadbeef> v2 {
    }
    Unreachable
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v1:Object = LoadArg<0>
    v2:LongExact = GuardType<LongExact> v1 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v4:Bottom = GuardIs<0xdeadbeef> v2 {
    }
    Unreachable
  }
}
--- Test Name ---
CompareOfBoxedBoolToTrueSimplifiedToOriginalBool
--- Input ---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0, CBool>
    v1 = PrimitiveBoxBool v0
    v2 = LoadConst<Bool[True]>
    v3 = PrimitiveCompare<Equal> v1 v2
    Return<CBool> v3
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:CBool = LoadArg<0, CBool>
    v1:Bool = PrimitiveBoxBool v0
    v2:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return<CBool> v0
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:CBool = LoadArg<0, CBool>
    v1:Bool = PrimitiveBoxBool v0
    v2:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return<CBool> v0
  }
}
--- Test Name ---
BooleanNotTurnsIntoPrimitive
--- Input ---
# HIR
fun jittestmodule:test {
  bb 0 {
    v1 = LoadArg<0; "x", Bool>
    v2 = UnaryOp<Not> v1
    Return v2
  }
}
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v1:Bool = LoadArg<0, Bool>
    UseType<Bool> v1
    v3:CBool = PrimitiveUnbox<CBool> v1
    v4:CBool = PrimitiveUnaryOp<NotInt> v3
    v5:Bool = PrimitiveBoxBool v4
    Return v5
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v1:Bool = LoadArg<0, Bool>
    UseType<Bool> v1
    v3:CBool = PrimitiveUnbox<CBool> v1
    v4:CBool = PrimitiveUnaryOp<NotInt> v3
    v5:Bool = PrimitiveBoxBool v4
    Return v5
  }
}
--- Test Name ---
GetLengthWithListTurnsIntoLoadField
--- Input ---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = RefineType<ListExact> v0
    v2 = GetLength v1
    Return v2
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:ListExact = RefineType<ListExact> v0
    UseType<ListExact> v1
    v3:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v1
    v4:LongExact = PrimitiveBox<CInt64> v3 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:ListExact = RefineType<ListExact> v0
    UseType<ListExact> v1
    v3:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v1
    v4:LongExact = PrimitiveBox<CInt64> v3 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Test Name ---
GetLengthWithTupleTurnsIntoLoadField
--- Input ---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = RefineType<TupleExact> v0
    v2 = GetLength v1
    Return v2
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:TupleExact = RefineType<TupleExact> v0
    UseType<TupleExact> v1
    v3:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v1
    v4:LongExact = PrimitiveBox<CInt64> v3 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:TupleExact = RefineType<TupleExact> v0
    UseType<TupleExact> v1
    v3:CInt64 = LoadField<ob_size@16, CInt64, borrowed> v1
    v4:LongExact = PrimitiveBox<CInt64> v3 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v4
  }
}
--- Test Name ---
GetLengthWithUnknownRemainsGetLength
--- Input ---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0; "a">
    v1 = GetLength v0
    Return v1
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:LongExact = GetLength v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v1
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:Object = LoadArg<0>
    v1:LongExact = GetLength v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return v1
  }
}
--- Test Name ---
CheckSequenceBoundsWithKnownInBoundsIndexEliminated
--- Input ---
# HIR
fun test {
  bb 0 {
    v0 = LoadConst<CInt64[63]>
    v1 = MakeTuple<1> v0
    v2 = LoadConst<CInt64[0]>
    v3 = CheckSequenceBounds v1 v2
    Return<CInt64> v3
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:CInt64[63] = LoadConst<CInt64[63]>
    v1:MortalTupleExact = MakeTuple<1> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v2:CInt64[0] = LoadConst<CInt64[0]>
    UseType<MortalTupleExact> v1
    UseType<CInt64[0]> v2
    Return<CInt64> v2
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:CInt64[63] = LoadConst<CInt64[63]>
    v1:MortalTupleExact = MakeTuple<1> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v2:CInt64[0] = LoadConst<CInt64[0]>
    UseType<MortalTupleExact> v1
    UseType<CInt64[0]> v2
    Return<CInt64> v2
  }
}
--- Test Name ---
CheckSequenceBoundsWithKnownInBoundsNegativeIndexEliminated
--- Input ---
# HIR
fun test {
  bb 0 {
    v0 = LoadConst<CInt64[63]>
    v1 = MakeTuple<1> v0
    v2 = LoadConst<CInt64[-1]>
    v3 = CheckSequenceBounds v1 v2
    Return<CInt64> v3
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:CInt64[63] = LoadConst<CInt64[63]>
    v1:MortalTupleExact = MakeTuple<1> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v2:CInt64[-1] = LoadConst<CInt64[-1]>
    UseType<MortalTupleExact> v1
    UseType<CInt64[-1]> v2
    v4:CInt64[0] = LoadConst<CInt64[0]>
    Return<CInt64> v4
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:CInt64[63] = LoadConst<CInt64[63]>
    v1:MortalTupleExact = MakeTuple<1> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v2:CInt64[-1] = LoadConst<CInt64[-1]>
    UseType<MortalTupleExact> v1
    UseType<CInt64[-1]> v2
    v4:CInt64[0] = LoadConst<CInt64[0]>
    Return<CInt64> v4
  }
}
--- Test Name ---
CheckSequenceBoundsWithKnownOutOfBoundsIndexNotEliminated
--- Input ---
# HIR
fun test {
  bb 0 {
    v0 = LoadConst<CInt64[63]>
    v1 = MakeTuple<1> v0
    v2 = LoadConst<CInt64[1]>
    v3 = CheckSequenceBounds v1 v2
    Return<CInt64> v3
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:CInt64[63] = LoadConst<CInt64[63]>
    v1:MortalTupleExact = MakeTuple<1> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v2:CInt64[1] = LoadConst<CInt64[1]>
    v3:CInt64 = CheckSequenceBounds v1 v2 {
    }
    Return<CInt64> v3
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:CInt64[63] = LoadConst<CInt64[63]>
    v1:MortalTupleExact = MakeTuple<1> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    v2:CInt64[1] = LoadConst<CInt64[1]>
    v3:CInt64 = CheckSequenceBounds v1 v2 {
    }
    Return<CInt64> v3
  }
}
--- Test Name ---
LoadArrayItemWithInBoundsIndexIntoMakeListTupleReachesThroughIt
--- Input ---
def test(x, y, z):
  t = (x, y, z)
  return t[1]
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v7:Object = LoadArg<0; "x">
    v8:Object = LoadArg<1; "y">
    v9:Object = LoadArg<2; "z">
    v10:Nullptr = LoadConst<Nullptr>
    Snapshot
    v14:MortalTupleExact = MakeTuple<3> v7 v8 v9 {
      FrameState {
        NextInstrOffset 8
        Locals<4> v7 v8 v9 v10
        Stack<3> v7 v8 v9
      }
    }
    Snapshot
    v17:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    UseType<TupleExact> v14
    UseType<LongExact> v17
    v23:CInt64[1] = LoadConst<CInt64[1]>
    v24:CInt64[0] = LoadConst<CInt64[0]>
    UseType<MortalTupleExact> v14
    UseType<CInt64[1]> v23
    UseType<TupleExact> v14
    UseType<CInt64[1]> v23
    Snapshot
    Return v8
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v10:Object = LoadArg<0; "x">
    v11:Object = LoadArg<1; "y">
    v12:Object = LoadArg<2; "z">
    v13:Func = LoadCurrentFunc
    v14:Nullptr = LoadConst<Nullptr>
    Snapshot
    v15:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v15
  }

  bb 2 (preds 0) {
    Snapshot
    v16:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<4> v10 v11 v12 v14
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v24:MortalTupleExact = MakeTuple<3> v10 v11 v12 {
      FrameState {
        NextInstrOffset 10
        Locals<4> v10 v11 v12 v14
        Stack<3> v10 v11 v12
      }
    }
    Snapshot
    v27:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    UseType<TupleExact> v24
    UseType<LongExact> v27
    v33:CInt64[1] = LoadConst<CInt64[1]>
    v34:CInt64[0] = LoadConst<CInt64[0]>
    UseType<MortalTupleExact> v24
    UseType<CInt64[1]> v33
    UseType<TupleExact> v24
    UseType<CInt64[1]> v33
    Snapshot
    Return v11
  }
}
--- Test Name ---
LoadArrayItemWithTooBigIndexIntoMakeListTupleKeepsLoadArrayItem
--- Input ---
def test(x, y, z):
  t = (x, y, z)
  return t[3]
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v7:Object = LoadArg<0; "x">
    v8:Object = LoadArg<1; "y">
    v9:Object = LoadArg<2; "z">
    v10:Nullptr = LoadConst<Nullptr>
    Snapshot
    v14:MortalTupleExact = MakeTuple<3> v7 v8 v9 {
      FrameState {
        NextInstrOffset 8
        Locals<4> v7 v8 v9 v10
        Stack<3> v7 v8 v9
      }
    }
    Snapshot
    v17:ImmortalLongExact[3] = LoadConst<ImmortalLongExact[3]>
    UseType<TupleExact> v14
    UseType<LongExact> v17
    v23:CInt64[3] = LoadConst<CInt64[3]>
    v24:CInt64[0] = LoadConst<CInt64[0]>
    v21:CInt64 = CheckSequenceBounds v14 v23 {
      FrameState {
        NextInstrOffset 16
        Locals<4> v7 v8 v9 v14
      }
    }
    v22:Object = LoadArrayItem<Offset[24]> v14 v21 v14
    Snapshot
    Return v22
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v10:Object = LoadArg<0; "x">
    v11:Object = LoadArg<1; "y">
    v12:Object = LoadArg<2; "z">
    v13:Func = LoadCurrentFunc
    v14:Nullptr = LoadConst<Nullptr>
    Snapshot
    v15:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v15
  }

  bb 2 (preds 0) {
    Snapshot
    v16:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<4> v10 v11 v12 v14
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v24:MortalTupleExact = MakeTuple<3> v10 v11 v12 {
      FrameState {
        NextInstrOffset 10
        Locals<4> v10 v11 v12 v14
        Stack<3> v10 v11 v12
      }
    }
    Snapshot
    v27:ImmortalLongExact[3] = LoadConst<ImmortalLongExact[3]>
    UseType<TupleExact> v24
    UseType<LongExact> v27
    v33:CInt64[3] = LoadConst<CInt64[3]>
    v34:CInt64[0] = LoadConst<CInt64[0]>
    v31:CInt64 = CheckSequenceBounds v24 v33 {
      FrameState {
        NextInstrOffset 18
        Locals<4> v10 v11 v12 v24
      }
    }
    v32:Object = LoadArrayItem<Offset[24]> v24 v31 v24
    Snapshot
    Return v32
  }
}
--- Test Name ---
UnpackSequenceWithCorrectNumberOfValuesReachesThroughAllocation
--- Input ---
def test(x, y, z):
  a, b, c = (x, y, z)
  return b
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v6:Object = LoadArg<0; "x">
    v7:Object = LoadArg<1; "y">
    v8:Object = LoadArg<2; "z">
    v9:Nullptr = LoadConst<Nullptr>
    Snapshot
    Return v7
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v9:Object = LoadArg<0; "x">
    v10:Object = LoadArg<1; "y">
    v11:Object = LoadArg<2; "z">
    v12:Func = LoadCurrentFunc
    v13:Nullptr = LoadConst<Nullptr>
    Snapshot
    v14:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v14
  }

  bb 2 (preds 0) {
    Snapshot
    v15:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<6> v9 v10 v11 v13 v13 v13
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    Return v10
  }
}
--- Test Name ---
UnpackSequenceWithIncorrectNumberOfValuesKeepsAllocation
--- Input ---
def test(x, y, z):
  a, c = (x, y, z)
  return a
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v14:Object = LoadArg<0; "x">
    v15:Object = LoadArg<1; "y">
    v16:Object = LoadArg<2; "z">
    v17:Nullptr = LoadConst<Nullptr>
    Snapshot
    v21:MortalTupleExact = MakeTuple<3> v14 v15 v16 {
      FrameState {
        NextInstrOffset 8
        Locals<5> v14 v15 v16 v17 v17
        Stack<3> v14 v15 v16
      }
    }
    Snapshot
    UseType<MortalTupleExact> v21
    v22:CInt64[24] = LoadConst<CInt64[24]>
    v23:CPtr = LoadFieldAddress v21 v22
    UseType<MortalTupleExact> v21
    v48:CInt64[3] = LoadConst<CInt64[3]>
    v27:CInt64[2] = LoadConst<CInt64[2]>
    UseType<CInt64[3]> v48
    UseType<CInt64[2]> v27
    v49:CBool[false] = LoadConst<CBool[false]>
    Snapshot
    Deopt {
      Descr 'UNPACK_SEQUENCE'
      GuiltyReg v21
    }
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v17:Object = LoadArg<0; "x">
    v18:Object = LoadArg<1; "y">
    v19:Object = LoadArg<2; "z">
    v20:Func = LoadCurrentFunc
    v21:Nullptr = LoadConst<Nullptr>
    Snapshot
    v22:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v22
  }

  bb 2 (preds 0) {
    Snapshot
    v23:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<5> v17 v18 v19 v21 v21
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v32:MortalTupleExact = MakeTuple<3> v17 v18 v19 {
      FrameState {
        NextInstrOffset 10
        Locals<5> v17 v18 v19 v21 v21
        Stack<3> v17 v18 v19
      }
    }
    Snapshot
    UseType<MortalTupleExact> v32
    v33:CInt64[24] = LoadConst<CInt64[24]>
    v34:CPtr = LoadFieldAddress v32 v33
    UseType<MortalTupleExact> v32
    v59:CInt64[3] = LoadConst<CInt64[3]>
    v38:CInt64[2] = LoadConst<CInt64[2]>
    UseType<CInt64[3]> v59
    UseType<CInt64[2]> v38
    v60:CBool[false] = LoadConst<CBool[false]>
    Snapshot
    Deopt {
      Descr 'UNPACK_SEQUENCE'
      GuiltyReg v32
    }
  }
}
--- Test Name ---
LoadVarObjectSizeWithConstTupleEmitsLoadConst
--- Input ---
def test():
  a, b, c = (1,2,3)
  return a
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v13:Nullptr = LoadConst<Nullptr>
    Snapshot
    v14:MortalTupleExact[tuple:0xdeadbeef] = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v14
    v15:CInt64[24] = LoadConst<CInt64[24]>
    v16:CPtr = LoadFieldAddress v14 v15
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v14
    v40:CInt64[3] = LoadConst<CInt64[3]>
    v20:CInt64[3] = LoadConst<CInt64[3]>
    UseType<CInt64[3]> v40
    UseType<CInt64[3]> v20
    v41:CBool[true] = LoadConst<CBool[true]>
    v22:CInt64[2] = LoadConst<CInt64[2]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v14
    UseType<CInt64[2]> v22
    v42:ImmortalLongExact[3] = LoadConst<ImmortalLongExact[3]>
    v25:CInt64[1] = LoadConst<CInt64[1]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v14
    UseType<CInt64[1]> v25
    v43:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v27:CInt64[0] = LoadConst<CInt64[0]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v14
    UseType<CInt64[0]> v27
    v44:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    Snapshot
    Return v44
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v16:Func = LoadCurrentFunc
    v17:Nullptr = LoadConst<Nullptr>
    Snapshot
    v18:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v18
  }

  bb 2 (preds 0) {
    Snapshot
    v19:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<3> v17 v17 v17
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v23:MortalTupleExact[tuple:0xdeadbeef] = LoadConst<MortalTupleExact[tuple:0xdeadbeef]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v23
    v24:CInt64[24] = LoadConst<CInt64[24]>
    v25:CPtr = LoadFieldAddress v23 v24
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v23
    v49:CInt64[3] = LoadConst<CInt64[3]>
    v29:CInt64[3] = LoadConst<CInt64[3]>
    UseType<CInt64[3]> v49
    UseType<CInt64[3]> v29
    v50:CBool[true] = LoadConst<CBool[true]>
    v31:CInt64[2] = LoadConst<CInt64[2]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v23
    UseType<CInt64[2]> v31
    v51:ImmortalLongExact[3] = LoadConst<ImmortalLongExact[3]>
    v34:CInt64[1] = LoadConst<CInt64[1]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v23
    UseType<CInt64[1]> v34
    v52:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v36:CInt64[0] = LoadConst<CInt64[0]>
    UseType<MortalTupleExact[tuple:0xdeadbeef]> v23
    UseType<CInt64[0]> v36
    v53:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    Snapshot
    Return v53
  }
}
--- Test Name ---
PrimitiveBoxWithTrueEmitsLoadConstTrue
--- Input ---
# HIR
fun jittestmodule:test {
  bb 0 {
    v0 = LoadConst<CBool[true]>
    v1 = PrimitiveBoxBool v0
    Return v1
  }
}
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v0:CBool[true] = LoadConst<CBool[true]>
    UseType<CBool[true]> v0
    v2:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v2
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v0:CBool[true] = LoadConst<CBool[true]>
    UseType<CBool[true]> v0
    v2:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v2
  }
}
--- Test Name ---
PrimitiveBoxWithFalseEmitsLoadConstFalse
--- Input ---
# HIR
fun jittestmodule:test {
  bb 0 {
    v0 = LoadConst<CBool[false]>
    v1 = PrimitiveBoxBool v0
    Return v1
  }
}
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v0:CBool[false] = LoadConst<CBool[false]>
    UseType<CBool[false]> v0
    v2:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v2
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v0:CBool[false] = LoadConst<CBool[false]>
    UseType<CBool[false]> v0
    v2:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v2
  }
}
--- Test Name ---
PrimitiveCompareEqualWithEqualInputsEmitsLoadConstTrue
--- Input ---
# HIR
fun jittestmodule:test {
  bb 0 {
    v0 = LoadConst<CInt32[123]>
    v1 = LoadConst<CInt32[123]>
    v2 = PrimitiveCompare<Equal> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32[123] = LoadConst<CInt32[123]>
    v1:CInt32[123] = LoadConst<CInt32[123]>
    UseType<CInt32[123]> v0
    UseType<CInt32[123]> v1
    v4:CBool[true] = LoadConst<CBool[true]>
    UseType<CBool[true]> v4
    v5:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v5
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32[123] = LoadConst<CInt32[123]>
    v1:CInt32[123] = LoadConst<CInt32[123]>
    UseType<CInt32[123]> v0
    UseType<CInt32[123]> v1
    v4:CBool[true] = LoadConst<CBool[true]>
    UseType<CBool[true]> v4
    v5:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v5
  }
}
--- Test Name ---
PrimitiveCompareEqualWithInequalInputsEmitsLoadConstFalse
--- Input ---
# HIR
fun jittestmodule:test {
  bb 0 {
    v0 = LoadConst<CInt32[123]>
    v1 = LoadConst<CInt32[456]>
    v2 = PrimitiveCompare<Equal> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32[123] = LoadConst<CInt32[123]>
    v1:CInt32[456] = LoadConst<CInt32[456]>
    UseType<CInt32[123]> v0
    UseType<CInt32[456]> v1
    v4:CBool[false] = LoadConst<CBool[false]>
    UseType<CBool[false]> v4
    v5:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v5
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32[123] = LoadConst<CInt32[123]>
    v1:CInt32[456] = LoadConst<CInt32[456]>
    UseType<CInt32[123]> v0
    UseType<CInt32[456]> v1
    v4:CBool[false] = LoadConst<CBool[false]>
    UseType<CBool[false]> v4
    v5:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v5
  }
}
--- Test Name ---
PrimitiveCompareEqualWithUnknownInputsDoesNotSimplify
--- Input ---
# HIR
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x", CInt32>
    v1 = LoadConst<CInt32[123]>
    v2 = PrimitiveCompare<Equal> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32 = LoadArg<0, CInt32>
    v1:CInt32[123] = LoadConst<CInt32[123]>
    v2:CBool = PrimitiveCompare<Equal> v0 v1
    v3:Bool = PrimitiveBoxBool v2
    Return v3
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32 = LoadArg<0, CInt32>
    v1:CInt32[123] = LoadConst<CInt32[123]>
    v2:CBool = PrimitiveCompare<Equal> v0 v1
    v3:Bool = PrimitiveBoxBool v2
    Return v3
  }
}
--- Test Name ---
PrimitiveCompareNotEqualWithEqualInputsEmitsLoadConstFalse
--- Input ---
# HIR
fun jittestmodule:test {
  bb 0 {
    v0 = LoadConst<CInt32[123]>
    v1 = LoadConst<CInt32[123]>
    v2 = PrimitiveCompare<NotEqual> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32[123] = LoadConst<CInt32[123]>
    v1:CInt32[123] = LoadConst<CInt32[123]>
    UseType<CInt32[123]> v0
    UseType<CInt32[123]> v1
    v4:CBool[false] = LoadConst<CBool[false]>
    UseType<CBool[false]> v4
    v5:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v5
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32[123] = LoadConst<CInt32[123]>
    v1:CInt32[123] = LoadConst<CInt32[123]>
    UseType<CInt32[123]> v0
    UseType<CInt32[123]> v1
    v4:CBool[false] = LoadConst<CBool[false]>
    UseType<CBool[false]> v4
    v5:ImmortalBool[False] = LoadConst<ImmortalBool[False]>
    Return v5
  }
}
--- Test Name ---
PrimitiveCompareNotEqualWithInequalInputsEmitsLoadConstTrue
--- Input ---
# HIR
fun jittestmodule:test {
  bb 0 {
    v0 = LoadConst<CInt32[123]>
    v1 = LoadConst<CInt32[456]>
    v2 = PrimitiveCompare<NotEqual> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32[123] = LoadConst<CInt32[123]>
    v1:CInt32[456] = LoadConst<CInt32[456]>
    UseType<CInt32[123]> v0
    UseType<CInt32[456]> v1
    v4:CBool[true] = LoadConst<CBool[true]>
    UseType<CBool[true]> v4
    v5:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v5
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32[123] = LoadConst<CInt32[123]>
    v1:CInt32[456] = LoadConst<CInt32[456]>
    UseType<CInt32[123]> v0
    UseType<CInt32[456]> v1
    v4:CBool[true] = LoadConst<CBool[true]>
    UseType<CBool[true]> v4
    v5:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    Return v5
  }
}
--- Test Name ---
PrimitiveCompareNotEqualWithUnknownInputsDoesNotSimplify
--- Input ---
# HIR
fun jittestmodule:test {
  bb 0 {
    v0 = LoadArg<0; "x", CInt32>
    v1 = LoadConst<CInt32[123]>
    v2 = PrimitiveCompare<NotEqual> v0 v1
    v3 = PrimitiveBoxBool v2
    Return v3
  }
}
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32 = LoadArg<0, CInt32>
    v1:CInt32[123] = LoadConst<CInt32[123]>
    v2:CBool = PrimitiveCompare<NotEqual> v0 v1
    v3:Bool = PrimitiveBoxBool v2
    Return v3
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v0:CInt32 = LoadArg<0, CInt32>
    v1:CInt32[123] = LoadConst<CInt32[123]>
    v2:CBool = PrimitiveCompare<NotEqual> v0 v1
    v3:Bool = PrimitiveBoxBool v2
    Return v3
  }
}
--- Test Name ---
PrimitiveCompareEqualBool
--- Input ---
def test(x):
  return (x is not None) == True
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v6:Object = LoadArg<0; "x">
    Snapshot
    v8:NoneType = LoadConst<NoneType>
    v9:CBool = PrimitiveCompare<NotEqual> v6 v8
    v10:Bool = PrimitiveBoxBool v9
    v11:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<Bool> v10
    UseType<Bool> v11
    v14:Bool = PrimitiveBoxBool v9
    Snapshot
    Return v14
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v9:Object = LoadArg<0; "x">
    v10:Func = LoadCurrentFunc
    Snapshot
    v11:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v11
  }

  bb 2 (preds 0) {
    Snapshot
    v12:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<1> v9
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v15:NoneType = LoadConst<NoneType>
    v16:CBool = PrimitiveCompare<NotEqual> v9 v15
    v17:Bool = PrimitiveBoxBool v16
    v18:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<Bool> v17
    UseType<Bool> v18
    v21:Bool = PrimitiveBoxBool v16
    Snapshot
    Return v21
  }
}
--- Test Name ---
PrimitiveCompareNotEqualBool
--- Input ---
def test(x):
  return (x is not None) != True
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v6:Object = LoadArg<0; "x">
    Snapshot
    v8:NoneType = LoadConst<NoneType>
    v9:CBool = PrimitiveCompare<NotEqual> v6 v8
    v10:Bool = PrimitiveBoxBool v9
    v11:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<Bool> v10
    UseType<Bool> v11
    v13:CBool = PrimitiveCompare<NotEqual> v10 v11
    v14:Bool = PrimitiveBoxBool v13
    Snapshot
    Return v14
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v9:Object = LoadArg<0; "x">
    v10:Func = LoadCurrentFunc
    Snapshot
    v11:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v11
  }

  bb 2 (preds 0) {
    Snapshot
    v12:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<1> v9
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v15:NoneType = LoadConst<NoneType>
    v16:CBool = PrimitiveCompare<NotEqual> v9 v15
    v17:Bool = PrimitiveBoxBool v16
    v18:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    UseType<Bool> v17
    UseType<Bool> v18
    v20:CBool = PrimitiveCompare<NotEqual> v17 v18
    v21:Bool = PrimitiveBoxBool v20
    Snapshot
    Return v21
  }
}
--- Test Name ---
PrimitiveCompareLessThanBool
--- Input ---
def test(x):
  return (x is not None) < True
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v6:Object = LoadArg<0; "x">
    Snapshot
    v8:NoneType = LoadConst<NoneType>
    v9:CBool = PrimitiveCompare<NotEqual> v6 v8
    v10:Bool = PrimitiveBoxBool v9
    v11:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    v12:Object = Compare<LessThan> v10 v11 {
      FrameState {
        NextInstrOffset 10
        Locals<1> v6
      }
    }
    Snapshot
    Return v12
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v9:Object = LoadArg<0; "x">
    v10:Func = LoadCurrentFunc
    Snapshot
    v11:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v11
  }

  bb 2 (preds 0) {
    Snapshot
    v12:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<1> v9
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v15:NoneType = LoadConst<NoneType>
    v16:CBool = PrimitiveCompare<NotEqual> v9 v15
    v17:Bool = PrimitiveBoxBool v16
    v18:ImmortalBool[True] = LoadConst<ImmortalBool[True]>
    v19:Object = Compare<LessThan> v17 v18 {
      FrameState {
        NextInstrOffset 12
        Locals<1> v9
      }
    }
    Snapshot
    Return v19
  }
}
--- Test Name ---
LoadVarObjectSizeWithKnownTupleElidesEmitsLoadConst
--- Input ---
def test(a, b, c):
  d, e, f, _ = (a, b, c, 1)  # the 1 forces an UNPACK_SEQUENCE
  return d
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v19:Object = LoadArg<0; "a">
    v20:Object = LoadArg<1; "b">
    v21:Object = LoadArg<2; "c">
    v22:Nullptr = LoadConst<Nullptr>
    Snapshot
    v26:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v27:MortalTupleExact = MakeTuple<4> v19 v20 v21 v26 {
      FrameState {
        NextInstrOffset 10
        Locals<7> v19 v20 v21 v22 v22 v22 v22
        Stack<4> v19 v20 v21 v26
      }
    }
    Snapshot
    UseType<MortalTupleExact> v27
    v28:CInt64[24] = LoadConst<CInt64[24]>
    v29:CPtr = LoadFieldAddress v27 v28
    UseType<MortalTupleExact> v27
    v64:CInt64[4] = LoadConst<CInt64[4]>
    v33:CInt64[4] = LoadConst<CInt64[4]>
    UseType<CInt64[4]> v64
    UseType<CInt64[4]> v33
    v65:CBool[true] = LoadConst<CBool[true]>
    v35:CInt64[3] = LoadConst<CInt64[3]>
    UseType<TupleExact> v27
    UseType<CInt64[3]> v35
    v38:CInt64[2] = LoadConst<CInt64[2]>
    UseType<TupleExact> v27
    UseType<CInt64[2]> v38
    v40:CInt64[1] = LoadConst<CInt64[1]>
    UseType<TupleExact> v27
    UseType<CInt64[1]> v40
    v42:CInt64[0] = LoadConst<CInt64[0]>
    UseType<TupleExact> v27
    UseType<CInt64[0]> v42
    Snapshot
    Return v19
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v22:Object = LoadArg<0; "a">
    v23:Object = LoadArg<1; "b">
    v24:Object = LoadArg<2; "c">
    v25:Func = LoadCurrentFunc
    v26:Nullptr = LoadConst<Nullptr>
    Snapshot
    v27:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v27
  }

  bb 2 (preds 0) {
    Snapshot
    v28:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<7> v22 v23 v24 v26 v26 v26 v26
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v39:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v40:MortalTupleExact = MakeTuple<4> v22 v23 v24 v39 {
      FrameState {
        NextInstrOffset 12
        Locals<7> v22 v23 v24 v26 v26 v26 v26
        Stack<4> v22 v23 v24 v39
      }
    }
    Snapshot
    UseType<MortalTupleExact> v40
    v41:CInt64[24] = LoadConst<CInt64[24]>
    v42:CPtr = LoadFieldAddress v40 v41
    UseType<MortalTupleExact> v40
    v77:CInt64[4] = LoadConst<CInt64[4]>
    v46:CInt64[4] = LoadConst<CInt64[4]>
    UseType<CInt64[4]> v77
    UseType<CInt64[4]> v46
    v78:CBool[true] = LoadConst<CBool[true]>
    v48:CInt64[3] = LoadConst<CInt64[3]>
    UseType<TupleExact> v40
    UseType<CInt64[3]> v48
    v51:CInt64[2] = LoadConst<CInt64[2]>
    UseType<TupleExact> v40
    UseType<CInt64[2]> v51
    v53:CInt64[1] = LoadConst<CInt64[1]>
    UseType<TupleExact> v40
    UseType<CInt64[1]> v53
    v55:CInt64[0] = LoadConst<CInt64[0]>
    UseType<TupleExact> v40
    UseType<CInt64[0]> v55
    Snapshot
    Return v22
  }
}
--- Test Name ---
VectorCallWithTooManyArgsStaysTheSame
--- Input ---
def foo(x, y=4):
  return x

def test():
  return foo(1, 2, 3)
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v5:OptObject = LoadGlobalCached<0; "foo">
    v6:MortalFunc[function:0xdeadbeef] = GuardIs<0xdeadbeef> v5 {
      Descr 'LOAD_GLOBAL: foo'
    }
    Snapshot
    v7:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v8:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v9:ImmortalLongExact[3] = LoadConst<ImmortalLongExact[3]>
    v10:Object = VectorCall<3> v6 v7 v8 v9 {
      FrameState {
        NextInstrOffset 10
      }
    }
    Snapshot
    Return v10
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v9:Func = LoadCurrentFunc
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v12:Nullptr = LoadConst<Nullptr>
    v13:OptObject = LoadGlobalCached<0; "foo">
    v14:MortalFunc[function:0xdeadbeef] = GuardIs<0xdeadbeef> v13 {
      Descr 'LOAD_GLOBAL: foo'
    }
    Snapshot
    v15:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v16:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v17:ImmortalLongExact[3] = LoadConst<ImmortalLongExact[3]>
    v18:Object = CallMethod<5> v12 v14 v15 v16 v17 {
      FrameState {
        NextInstrOffset 20
      }
    }
    Snapshot
    Return v18
  }
}
--- Test Name ---
VectorCallWithUnnecessaryDefaultsKeepsArgs
--- Input ---
def foo(x, y=3):
  return x

def test():
  return foo(1, 2)
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v4:OptObject = LoadGlobalCached<0; "foo">
    v5:MortalFunc[function:0xdeadbeef] = GuardIs<0xdeadbeef> v4 {
      Descr 'LOAD_GLOBAL: foo'
    }
    Snapshot
    v6:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v7:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v8:Object = VectorCall<2> v5 v6 v7 {
      FrameState {
        NextInstrOffset 8
      }
    }
    Snapshot
    Return v8
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v8:Func = LoadCurrentFunc
    Snapshot
    v9:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v9
  }

  bb 2 (preds 0) {
    Snapshot
    v10:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v11:Nullptr = LoadConst<Nullptr>
    v12:OptObject = LoadGlobalCached<0; "foo">
    v13:MortalFunc[function:0xdeadbeef] = GuardIs<0xdeadbeef> v12 {
      Descr 'LOAD_GLOBAL: foo'
    }
    Snapshot
    v14:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v15:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v16:Object = CallMethod<4> v11 v13 v14 v15 {
      FrameState {
        NextInstrOffset 18
      }
    }
    Snapshot
    Return v16
  }
}
--- Test Name ---
VectorCallHasDefaultsFilledIn
--- Input ---
def foo(a, b, c=3, d=4):
  return x

def test():
  return foo(1, 2)
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v4:OptObject = LoadGlobalCached<0; "foo">
    v5:MortalFunc[function:0xdeadbeef] = GuardIs<0xdeadbeef> v4 {
      Descr 'LOAD_GLOBAL: foo'
    }
    Snapshot
    v6:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v7:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v9:ImmortalLongExact[3] = LoadConst<ImmortalLongExact[3]>
    v10:ImmortalLongExact[4] = LoadConst<ImmortalLongExact[4]>
    v11:Tuple = LoadField<func_defaults@56, Tuple, borrowed> v5
    v12:MortalTupleExact[tuple:0xdeadbeef] = GuardIs<0xdeadbeef> v11 {
    }
    v13:Object = VectorCall<4> v5 v6 v7 v9 v10 {
      FrameState {
        NextInstrOffset 8
      }
    }
    Snapshot
    Return v13
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v8:Func = LoadCurrentFunc
    Snapshot
    v9:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v9
  }

  bb 2 (preds 0) {
    Snapshot
    v10:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v11:Nullptr = LoadConst<Nullptr>
    v12:OptObject = LoadGlobalCached<0; "foo">
    v13:MortalFunc[function:0xdeadbeef] = GuardIs<0xdeadbeef> v12 {
      Descr 'LOAD_GLOBAL: foo'
    }
    Snapshot
    v14:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v15:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v16:Object = CallMethod<4> v11 v13 v14 v15 {
      FrameState {
        NextInstrOffset 18
      }
    }
    Snapshot
    Return v16
  }
}
--- Test Name ---
LoadMethodFromTypeIsSpecialized
--- Input ---
class Foo:
  def regular_meth(x, y):
    return x + y
def test():
  return Foo.regular_meth(1, 2)
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v6:OptObject = LoadGlobalCached<0; "Foo">
    v7:MortalTypeExact[Foo:obj] = GuardIs<0xdeadbeef> v6 {
      Descr 'LOAD_GLOBAL: Foo'
    }
    Snapshot
    UseType<Type> v7
    v13:OptType = LoadTypeMethodCacheEntryType<0>
    v14:CBool = PrimitiveCompare<Equal> v13 v7
    CondBranch<1, 2> v14
  }

  bb 1 (preds 0) {
    v15:Object = LoadTypeMethodCacheEntryValue<0> v7
    Branch<3>
  }

  bb 2 (preds 0) {
    v16:Object = FillTypeMethodCache<0, 1> v7 {
      FrameState {
        NextInstrOffset 4
      }
    }
    Branch<3>
  }

  bb 3 (preds 1, 2) {
    v17:Object = Phi<1, 2> v15 v16
    v9:OptObject = GetSecondOutput<OptObject> v17
    Snapshot
    v10:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v11:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v12:Object = CallMethod<4> v17 v9 v10 v11 {
      FrameState {
        NextInstrOffset 10
      }
    }
    Snapshot
    Return v12
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v9:Func = LoadCurrentFunc
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v12:OptObject = LoadGlobalCached<0; "Foo">
    v13:MortalTypeExact[Foo:obj] = GuardIs<0xdeadbeef> v12 {
      Descr 'LOAD_GLOBAL: Foo'
    }
    Snapshot
    UseType<Type> v13
    v19:OptType = LoadTypeMethodCacheEntryType<0>
    v20:CBool = PrimitiveCompare<Equal> v19 v13
    CondBranch<3, 4> v20
  }

  bb 3 (preds 1) {
    v21:Object = LoadTypeMethodCacheEntryValue<0> v13
    Branch<5>
  }

  bb 4 (preds 1) {
    v22:Object = FillTypeMethodCache<0, 1> v13 {
      FrameState {
        NextInstrOffset 14
      }
    }
    Branch<5>
  }

  bb 5 (preds 3, 4) {
    v23:Object = Phi<3, 4> v21 v22
    v15:OptObject = GetSecondOutput<OptObject> v23
    Snapshot
    v16:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v17:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v18:Object = CallMethod<4> v23 v15 v16 v17 {
      FrameState {
        NextInstrOffset 38
      }
    }
    Snapshot
    Return v18
  }
}
--- Test Name ---
LoadClassMethodFromTypeIsSpecialized
--- Input ---
class Foo:
  @classmethod
  def meth(cls, x, y):
    return x + y

def test():
  return Foo.meth(1, 2)
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v6:OptObject = LoadGlobalCached<0; "Foo">
    v7:MortalTypeExact[Foo:obj] = GuardIs<0xdeadbeef> v6 {
      Descr 'LOAD_GLOBAL: Foo'
    }
    Snapshot
    UseType<Type> v7
    v13:OptType = LoadTypeMethodCacheEntryType<0>
    v14:CBool = PrimitiveCompare<Equal> v13 v7
    CondBranch<1, 2> v14
  }

  bb 1 (preds 0) {
    v15:Object = LoadTypeMethodCacheEntryValue<0> v7
    Branch<3>
  }

  bb 2 (preds 0) {
    v16:Object = FillTypeMethodCache<0, 1> v7 {
      FrameState {
        NextInstrOffset 4
      }
    }
    Branch<3>
  }

  bb 3 (preds 1, 2) {
    v17:Object = Phi<1, 2> v15 v16
    v9:OptObject = GetSecondOutput<OptObject> v17
    Snapshot
    v10:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v11:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v12:Object = CallMethod<4> v17 v9 v10 v11 {
      FrameState {
        NextInstrOffset 10
      }
    }
    Snapshot
    Return v12
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v9:Func = LoadCurrentFunc
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v12:OptObject = LoadGlobalCached<0; "Foo">
    v13:MortalTypeExact[Foo:obj] = GuardIs<0xdeadbeef> v12 {
      Descr 'LOAD_GLOBAL: Foo'
    }
    Snapshot
    UseType<Type> v13
    v19:OptType = LoadTypeMethodCacheEntryType<0>
    v20:CBool = PrimitiveCompare<Equal> v19 v13
    CondBranch<3, 4> v20
  }

  bb 3 (preds 1) {
    v21:Object = LoadTypeMethodCacheEntryValue<0> v13
    Branch<5>
  }

  bb 4 (preds 1) {
    v22:Object = FillTypeMethodCache<0, 1> v13 {
      FrameState {
        NextInstrOffset 14
      }
    }
    Branch<5>
  }

  bb 5 (preds 3, 4) {
    v23:Object = Phi<3, 4> v21 v22
    v15:OptObject = GetSecondOutput<OptObject> v23
    Snapshot
    v16:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v17:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v18:Object = CallMethod<4> v23 v15 v16 v17 {
      FrameState {
        NextInstrOffset 38
      }
    }
    Snapshot
    Return v18
  }
}
--- Test Name ---
LoadStaticMethodFromTypeIsSpecialized
--- Input ---
class Foo:
  @staticmethod
  def meth(x, y):
    return x + y

def test():
  return Foo.meth(1, 2)
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v6:OptObject = LoadGlobalCached<0; "Foo">
    v7:MortalTypeExact[Foo:obj] = GuardIs<0xdeadbeef> v6 {
      Descr 'LOAD_GLOBAL: Foo'
    }
    Snapshot
    UseType<Type> v7
    v13:OptType = LoadTypeMethodCacheEntryType<0>
    v14:CBool = PrimitiveCompare<Equal> v13 v7
    CondBranch<1, 2> v14
  }

  bb 1 (preds 0) {
    v15:Object = LoadTypeMethodCacheEntryValue<0> v7
    Branch<3>
  }

  bb 2 (preds 0) {
    v16:Object = FillTypeMethodCache<0, 1> v7 {
      FrameState {
        NextInstrOffset 4
      }
    }
    Branch<3>
  }

  bb 3 (preds 1, 2) {
    v17:Object = Phi<1, 2> v15 v16
    v9:OptObject = GetSecondOutput<OptObject> v17
    Snapshot
    v10:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v11:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v12:Object = CallMethod<4> v17 v9 v10 v11 {
      FrameState {
        NextInstrOffset 10
      }
    }
    Snapshot
    Return v12
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v9:Func = LoadCurrentFunc
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v12:OptObject = LoadGlobalCached<0; "Foo">
    v13:MortalTypeExact[Foo:obj] = GuardIs<0xdeadbeef> v12 {
      Descr 'LOAD_GLOBAL: Foo'
    }
    Snapshot
    UseType<Type> v13
    v19:OptType = LoadTypeMethodCacheEntryType<0>
    v20:CBool = PrimitiveCompare<Equal> v19 v13
    CondBranch<3, 4> v20
  }

  bb 3 (preds 1) {
    v21:Object = LoadTypeMethodCacheEntryValue<0> v13
    Branch<5>
  }

  bb 4 (preds 1) {
    v22:Object = FillTypeMethodCache<0, 1> v13 {
      FrameState {
        NextInstrOffset 14
      }
    }
    Branch<5>
  }

  bb 5 (preds 3, 4) {
    v23:Object = Phi<3, 4> v21 v22
    v15:OptObject = GetSecondOutput<OptObject> v23
    Snapshot
    v16:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v17:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v18:Object = CallMethod<4> v23 v15 v16 v17 {
      FrameState {
        NextInstrOffset 38
      }
    }
    Snapshot
    Return v18
  }
}
--- Test Name ---
LoadMethodFromBuiltinTypeIsSpecialized
--- Input ---
def test():
  return int.__add__(1, 2)
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v6:OptObject = LoadGlobalCached<0; "int">
    v7:ImmortalTypeExact[int:obj] = GuardIs<0xdeadbeef> v6 {
      Descr 'LOAD_GLOBAL: int'
    }
    Snapshot
    UseType<Type> v7
    v13:OptType = LoadTypeMethodCacheEntryType<0>
    v14:CBool = PrimitiveCompare<Equal> v13 v7
    CondBranch<1, 2> v14
  }

  bb 1 (preds 0) {
    v15:Object = LoadTypeMethodCacheEntryValue<0> v7
    Branch<3>
  }

  bb 2 (preds 0) {
    v16:Object = FillTypeMethodCache<0, 1> v7 {
      FrameState {
        NextInstrOffset 4
      }
    }
    Branch<3>
  }

  bb 3 (preds 1, 2) {
    v17:Object = Phi<1, 2> v15 v16
    v9:OptObject = GetSecondOutput<OptObject> v17
    Snapshot
    v10:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v11:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v12:Object = CallMethod<4> v17 v9 v10 v11 {
      FrameState {
        NextInstrOffset 10
      }
    }
    Snapshot
    Return v12
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v9:Func = LoadCurrentFunc
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v12:OptObject = LoadGlobalCached<0; "int">
    v13:ImmortalTypeExact[int:obj] = GuardIs<0xdeadbeef> v12 {
      Descr 'LOAD_GLOBAL: int'
    }
    Snapshot
    UseType<Type> v13
    v19:OptType = LoadTypeMethodCacheEntryType<0>
    v20:CBool = PrimitiveCompare<Equal> v19 v13
    CondBranch<3, 4> v20
  }

  bb 3 (preds 1) {
    v21:Object = LoadTypeMethodCacheEntryValue<0> v13
    Branch<5>
  }

  bb 4 (preds 1) {
    v22:Object = FillTypeMethodCache<0, 1> v13 {
      FrameState {
        NextInstrOffset 14
      }
    }
    Branch<5>
  }

  bb 5 (preds 3, 4) {
    v23:Object = Phi<3, 4> v21 v22
    v15:OptObject = GetSecondOutput<OptObject> v23
    Snapshot
    v16:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v17:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    v18:Object = CallMethod<4> v23 v15 v16 v17 {
      FrameState {
        NextInstrOffset 38
      }
    }
    Snapshot
    Return v18
  }
}
--- Test Name ---
LoadMethodFromModuleIsSpecialized
--- Input ---
import time

def test():
  return time.time()
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v4:OptObject = LoadGlobalCached<0; "time">
    v5:MortalObjectUser[module:0xdeadbeef] = GuardIs<0xdeadbeef> v4 {
      Descr 'LOAD_GLOBAL: time'
    }
    Snapshot
    v9:Object = LoadModuleMethodCached<0; "time"> v5 {
      FrameState {
        NextInstrOffset 4
      }
    }
    v7:OptObject = GetSecondOutput<OptObject> v9
    Snapshot
    v8:Object = CallMethod<2> v9 v7 {
      FrameState {
        NextInstrOffset 6
      }
    }
    Snapshot
    Return v8
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v7:Func = LoadCurrentFunc
    Snapshot
    v8:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v8
  }

  bb 2 (preds 0) {
    Snapshot
    v9:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v10:Nullptr = LoadConst<Nullptr>
    v11:OptObject = LoadGlobalCached<0; "time">
    v12:MortalObjectUser[module:0xdeadbeef] = GuardIs<0xdeadbeef> v11 {
      Descr 'LOAD_GLOBAL: time'
    }
    Snapshot
    v15:Object = LoadAttrCached<0; "time"> v12 {
      FrameState {
        NextInstrOffset 14
        Stack<1> v10
      }
    }
    Snapshot
    v14:Object = CallMethod<2> v10 v15 {
      FrameState {
        NextInstrOffset 34
      }
    }
    Snapshot
    Return v14
  }
}
--- Test Name ---
LoadClassMethodFromInstanceIsUnspecialized
--- Input ---
class A:
  @classmethod
  def hello(cls):
    return 1
def test():
  return A().hello()
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    Snapshot
    v5:OptObject = LoadGlobalCached<0; "A">
    v6:MortalTypeExact[A:obj] = GuardIs<0xdeadbeef> v5 {
      Descr 'LOAD_GLOBAL: A'
    }
    Snapshot
    v7:Object = VectorCall<0> v6 {
      FrameState {
        NextInstrOffset 4
      }
    }
    Snapshot
    v11:Object = LoadMethodCached<1; "hello"> v7 {
      FrameState {
        NextInstrOffset 6
      }
    }
    v9:OptObject = GetSecondOutput<OptObject> v11
    Snapshot
    v10:Object = CallMethod<2> v11 v9 {
      FrameState {
        NextInstrOffset 8
      }
    }
    Snapshot
    Return v10
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v9:Func = LoadCurrentFunc
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v12:Nullptr = LoadConst<Nullptr>
    v13:OptObject = LoadGlobalCached<0; "A">
    v14:MortalTypeExact[A:obj] = GuardIs<0xdeadbeef> v13 {
      Descr 'LOAD_GLOBAL: A'
    }
    Snapshot
    v15:Object = CallMethod<2> v12 v14 {
      FrameState {
        NextInstrOffset 14
      }
    }
    Snapshot
    v19:Object = LoadMethodCached<1; "hello"> v15 {
      FrameState {
        NextInstrOffset 22
      }
    }
    v17:OptObject = GetSecondOutput<OptObject> v19
    Snapshot
    v18:Object = CallMethod<2> v19 v17 {
      FrameState {
        NextInstrOffset 42
      }
    }
    Snapshot
    Return v18
  }
}
--- Test Name ---
UnboxOfBoxedPrimitiveUsesOriginalPrimitive
--- Input ---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0; "a", CInt64>
    v1 = PrimitiveBox<CInt64> v0
    v2 = PrimitiveUnbox<CInt64> v1
    Return<CInt64> v2
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:CInt64 = LoadArg<0, CInt64>
    v1:LongExact = PrimitiveBox<CInt64> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return<CInt64> v0
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:CInt64 = LoadArg<0, CInt64>
    v1:LongExact = PrimitiveBox<CInt64> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Return<CInt64> v0
  }
}
--- Test Name ---
UnboxOfBoxedPrimitiveDoesNotSeeThroughPhi
--- Input ---
# HIR
fun test {
  bb 0 {
    v0 = LoadArg<0; "a", CInt64>
    v1 = LoadArg<1; "b", CInt64>
    v2 = LoadArg<2; "cond", CBool>
    CondBranch<1,2> v2
  }

  bb 1 {
    v3 = PrimitiveBox<CInt64> v0
    Branch<3>
  }

  bb 2 {
    v4 = PrimitiveBox<CInt64> v1
    Branch<3>
  }

  bb 3 {
    v5 = Phi<1, 2> v3 v4
    v6 = PrimitiveUnbox<CInt64> v5
    Return<CInt64> v6
  }
}
--- Expected 3.10 ---
fun test {
  bb 0 {
    v0:CInt64 = LoadArg<0, CInt64>
    v1:CInt64 = LoadArg<1, CInt64>
    v2:CBool = LoadArg<2, CBool>
    CondBranch<1, 2> v2
  }

  bb 1 (preds 0) {
    v3:LongExact = PrimitiveBox<CInt64> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Branch<3>
  }

  bb 2 (preds 0) {
    v4:LongExact = PrimitiveBox<CInt64> v1 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Branch<3>
  }

  bb 3 (preds 1, 2) {
    v5:LongExact = Phi<1, 2> v3 v4
    v6:CInt64 = PrimitiveUnbox<CInt64> v5
    Return<CInt64> v6
  }
}
--- Expected 3.12 ---
fun test {
  bb 0 {
    v0:CInt64 = LoadArg<0, CInt64>
    v1:CInt64 = LoadArg<1, CInt64>
    v2:CBool = LoadArg<2, CBool>
    CondBranch<1, 2> v2
  }

  bb 1 (preds 0) {
    v3:LongExact = PrimitiveBox<CInt64> v0 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Branch<3>
  }

  bb 2 (preds 0) {
    v4:LongExact = PrimitiveBox<CInt64> v1 {
      FrameState {
        NextInstrOffset 0
      }
    }
    Branch<3>
  }

  bb 3 (preds 1, 2) {
    v5:LongExact = Phi<1, 2> v3 v4
    v6:CInt64 = PrimitiveUnbox<CInt64> v5
    Return<CInt64> v6
  }
}
--- Test Name ---
TestCallBuiltinTypes
--- Input ---
class C:
  pass


class D(dict):
  pass

def test(x):
  return (bool(x), bytes(x), dict(x), float(x), list(x), set(x), tuple(x),
          type(x), str(x), int(x), object(x), C(x), D(x))
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v28:Object = LoadArg<0; "x">
    Snapshot
    v29:OptObject = LoadGlobalCached<0; "bool">
    v30:ImmortalTypeExact[bool:obj] = GuardIs<0xdeadbeef> v29 {
      Descr 'LOAD_GLOBAL: bool'
    }
    Snapshot
    v32:Bool = VectorCall<1> v30 v28 {
      FrameState {
        NextInstrOffset 6
        Locals<1> v28
      }
    }
    Snapshot
    v33:OptObject = LoadGlobalCached<1; "bytes">
    v34:ImmortalTypeExact[bytes:obj] = GuardIs<0xdeadbeef> v33 {
      Descr 'LOAD_GLOBAL: bytes'
    }
    Snapshot
    v36:BytesExact = VectorCall<1> v34 v28 {
      FrameState {
        NextInstrOffset 12
        Locals<1> v28
        Stack<1> v32
      }
    }
    Snapshot
    v37:OptObject = LoadGlobalCached<2; "dict">
    v38:ImmortalTypeExact[dict:obj] = GuardIs<0xdeadbeef> v37 {
      Descr 'LOAD_GLOBAL: dict'
    }
    Snapshot
    v40:DictExact = VectorCall<1> v38 v28 {
      FrameState {
        NextInstrOffset 18
        Locals<1> v28
        Stack<2> v32 v36
      }
    }
    Snapshot
    v41:OptObject = LoadGlobalCached<3; "float">
    v42:ImmortalTypeExact[float:obj] = GuardIs<0xdeadbeef> v41 {
      Descr 'LOAD_GLOBAL: float'
    }
    Snapshot
    v44:FloatExact = VectorCall<1> v42 v28 {
      FrameState {
        NextInstrOffset 24
        Locals<1> v28
        Stack<3> v32 v36 v40
      }
    }
    Snapshot
    v45:OptObject = LoadGlobalCached<4; "list">
    v46:ImmortalTypeExact[list:obj] = GuardIs<0xdeadbeef> v45 {
      Descr 'LOAD_GLOBAL: list'
    }
    Snapshot
    v48:ListExact = VectorCall<1> v46 v28 {
      FrameState {
        NextInstrOffset 30
        Locals<1> v28
        Stack<4> v32 v36 v40 v44
      }
    }
    Snapshot
    v49:OptObject = LoadGlobalCached<5; "set">
    v50:ImmortalTypeExact[set:obj] = GuardIs<0xdeadbeef> v49 {
      Descr 'LOAD_GLOBAL: set'
    }
    Snapshot
    v52:SetExact = VectorCall<1> v50 v28 {
      FrameState {
        NextInstrOffset 36
        Locals<1> v28
        Stack<5> v32 v36 v40 v44 v48
      }
    }
    Snapshot
    v53:OptObject = LoadGlobalCached<6; "tuple">
    v54:ImmortalTypeExact[tuple:obj] = GuardIs<0xdeadbeef> v53 {
      Descr 'LOAD_GLOBAL: tuple'
    }
    Snapshot
    v56:TupleExact = VectorCall<1> v54 v28 {
      FrameState {
        NextInstrOffset 42
        Locals<1> v28
        Stack<6> v32 v36 v40 v44 v48 v52
      }
    }
    Snapshot
    v57:OptObject = LoadGlobalCached<7; "type">
    v58:ImmortalTypeExact[type:obj] = GuardIs<0xdeadbeef> v57 {
      Descr 'LOAD_GLOBAL: type'
    }
    Snapshot
    UseType<ImmortalTypeExact[type:obj]> v58
    v82:Type = LoadField<ob_type@8, Type, borrowed> v28
    Snapshot
    v61:OptObject = LoadGlobalCached<8; "str">
    v62:ImmortalTypeExact[str:obj] = GuardIs<0xdeadbeef> v61 {
      Descr 'LOAD_GLOBAL: str'
    }
    Snapshot
    v64:UnicodeExact = VectorCall<1> v62 v28 {
      FrameState {
        NextInstrOffset 54
        Locals<1> v28
        Stack<8> v32 v36 v40 v44 v48 v52 v56 v82
      }
    }
    Snapshot
    v65:OptObject = LoadGlobalCached<9; "int">
    v66:ImmortalTypeExact[int:obj] = GuardIs<0xdeadbeef> v65 {
      Descr 'LOAD_GLOBAL: int'
    }
    Snapshot
    v68:LongExact = VectorCall<1> v66 v28 {
      FrameState {
        NextInstrOffset 60
        Locals<1> v28
        Stack<9> v32 v36 v40 v44 v48 v52 v56 v82 v64
      }
    }
    Snapshot
    v69:OptObject = LoadGlobalCached<10; "object">
    v70:ImmortalTypeExact[object:obj] = GuardIs<0xdeadbeef> v69 {
      Descr 'LOAD_GLOBAL: object'
    }
    Snapshot
    v72:ObjectExact = VectorCall<1> v70 v28 {
      FrameState {
        NextInstrOffset 66
        Locals<1> v28
        Stack<10> v32 v36 v40 v44 v48 v52 v56 v82 v64 v68
      }
    }
    Snapshot
    v73:OptObject = LoadGlobalCached<11; "C">
    v74:MortalTypeExact[C:obj] = GuardIs<0xdeadbeef> v73 {
      Descr 'LOAD_GLOBAL: C'
    }
    Snapshot
    v76:Object = VectorCall<1> v74 v28 {
      FrameState {
        NextInstrOffset 72
        Locals<1> v28
        Stack<11> v32 v36 v40 v44 v48 v52 v56 v82 v64 v68 v72
      }
    }
    Snapshot
    v77:OptObject = LoadGlobalCached<12; "D">
    v78:MortalTypeExact[D:obj] = GuardIs<0xdeadbeef> v77 {
      Descr 'LOAD_GLOBAL: D'
    }
    Snapshot
    v80:Object = VectorCall<1> v78 v28 {
      FrameState {
        NextInstrOffset 78
        Locals<1> v28
        Stack<12> v32 v36 v40 v44 v48 v52 v56 v82 v64 v68 v72 v76
      }
    }
    Snapshot
    v81:MortalTupleExact = MakeTuple<13> v32 v36 v40 v44 v48 v52 v56 v82 v64 v68 v72 v76 v80 {
      FrameState {
        NextInstrOffset 80
        Locals<1> v28
        Stack<13> v32 v36 v40 v44 v48 v52 v56 v82 v64 v68 v72 v76 v80
      }
    }
    Snapshot
    Return v81
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v44:Object = LoadArg<0; "x">
    v45:Func = LoadCurrentFunc
    Snapshot
    v46:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v46
  }

  bb 2 (preds 0) {
    Snapshot
    v47:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<1> v44
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v49:Nullptr = LoadConst<Nullptr>
    v50:OptObject = LoadGlobalCached<0; "bool">
    v51:ImmortalTypeExact[bool:obj] = GuardIs<0xdeadbeef> v50 {
      Descr 'LOAD_GLOBAL: bool'
    }
    Snapshot
    v53:Object = CallMethod<3> v49 v51 v44 {
      FrameState {
        NextInstrOffset 16
        Locals<1> v44
      }
    }
    Snapshot
    v54:Nullptr = LoadConst<Nullptr>
    v55:OptObject = LoadGlobalCached<1; "bytes">
    v56:ImmortalTypeExact[bytes:obj] = GuardIs<0xdeadbeef> v55 {
      Descr 'LOAD_GLOBAL: bytes'
    }
    Snapshot
    v58:Object = CallMethod<3> v54 v56 v44 {
      FrameState {
        NextInstrOffset 36
        Locals<1> v44
        Stack<1> v53
      }
    }
    Snapshot
    v59:Nullptr = LoadConst<Nullptr>
    v60:OptObject = LoadGlobalCached<2; "dict">
    v61:ImmortalTypeExact[dict:obj] = GuardIs<0xdeadbeef> v60 {
      Descr 'LOAD_GLOBAL: dict'
    }
    Snapshot
    v63:Object = CallMethod<3> v59 v61 v44 {
      FrameState {
        NextInstrOffset 56
        Locals<1> v44
        Stack<2> v53 v58
      }
    }
    Snapshot
    v64:Nullptr = LoadConst<Nullptr>
    v65:OptObject = LoadGlobalCached<3; "float">
    v66:ImmortalTypeExact[float:obj] = GuardIs<0xdeadbeef> v65 {
      Descr 'LOAD_GLOBAL: float'
    }
    Snapshot
    v68:Object = CallMethod<3> v64 v66 v44 {
      FrameState {
        NextInstrOffset 76
        Locals<1> v44
        Stack<3> v53 v58 v63
      }
    }
    Snapshot
    v69:Nullptr = LoadConst<Nullptr>
    v70:OptObject = LoadGlobalCached<4; "list">
    v71:ImmortalTypeExact[list:obj] = GuardIs<0xdeadbeef> v70 {
      Descr 'LOAD_GLOBAL: list'
    }
    Snapshot
    v73:Object = CallMethod<3> v69 v71 v44 {
      FrameState {
        NextInstrOffset 96
        Locals<1> v44
        Stack<4> v53 v58 v63 v68
      }
    }
    Snapshot
    v74:Nullptr = LoadConst<Nullptr>
    v75:OptObject = LoadGlobalCached<5; "set">
    v76:ImmortalTypeExact[set:obj] = GuardIs<0xdeadbeef> v75 {
      Descr 'LOAD_GLOBAL: set'
    }
    Snapshot
    v78:Object = CallMethod<3> v74 v76 v44 {
      FrameState {
        NextInstrOffset 116
        Locals<1> v44
        Stack<5> v53 v58 v63 v68 v73
      }
    }
    Snapshot
    v79:Nullptr = LoadConst<Nullptr>
    v80:OptObject = LoadGlobalCached<6; "tuple">
    v81:ImmortalTypeExact[tuple:obj] = GuardIs<0xdeadbeef> v80 {
      Descr 'LOAD_GLOBAL: tuple'
    }
    Snapshot
    v83:Object = CallMethod<3> v79 v81 v44 {
      FrameState {
        NextInstrOffset 136
        Locals<1> v44
        Stack<6> v53 v58 v63 v68 v73 v78
      }
    }
    Snapshot
    v84:Nullptr = LoadConst<Nullptr>
    v85:OptObject = LoadGlobalCached<7; "type">
    v86:ImmortalTypeExact[type:obj] = GuardIs<0xdeadbeef> v85 {
      Descr 'LOAD_GLOBAL: type'
    }
    Snapshot
    v88:Object = CallMethod<3> v84 v86 v44 {
      FrameState {
        NextInstrOffset 156
        Locals<1> v44
        Stack<7> v53 v58 v63 v68 v73 v78 v83
      }
    }
    Snapshot
    v89:Nullptr = LoadConst<Nullptr>
    v90:OptObject = LoadGlobalCached<8; "str">
    v91:ImmortalTypeExact[str:obj] = GuardIs<0xdeadbeef> v90 {
      Descr 'LOAD_GLOBAL: str'
    }
    Snapshot
    v93:Object = CallMethod<3> v89 v91 v44 {
      FrameState {
        NextInstrOffset 176
        Locals<1> v44
        Stack<8> v53 v58 v63 v68 v73 v78 v83 v88
      }
    }
    Snapshot
    v94:Nullptr = LoadConst<Nullptr>
    v95:OptObject = LoadGlobalCached<9; "int">
    v96:ImmortalTypeExact[int:obj] = GuardIs<0xdeadbeef> v95 {
      Descr 'LOAD_GLOBAL: int'
    }
    Snapshot
    v98:Object = CallMethod<3> v94 v96 v44 {
      FrameState {
        NextInstrOffset 196
        Locals<1> v44
        Stack<9> v53 v58 v63 v68 v73 v78 v83 v88 v93
      }
    }
    Snapshot
    v99:Nullptr = LoadConst<Nullptr>
    v100:OptObject = LoadGlobalCached<10; "object">
    v101:ImmortalTypeExact[object:obj] = GuardIs<0xdeadbeef> v100 {
      Descr 'LOAD_GLOBAL: object'
    }
    Snapshot
    v103:Object = CallMethod<3> v99 v101 v44 {
      FrameState {
        NextInstrOffset 216
        Locals<1> v44
        Stack<10> v53 v58 v63 v68 v73 v78 v83 v88 v93 v98
      }
    }
    Snapshot
    v104:Nullptr = LoadConst<Nullptr>
    v105:OptObject = LoadGlobalCached<11; "C">
    v106:MortalTypeExact[C:obj] = GuardIs<0xdeadbeef> v105 {
      Descr 'LOAD_GLOBAL: C'
    }
    Snapshot
    v108:Object = CallMethod<3> v104 v106 v44 {
      FrameState {
        NextInstrOffset 236
        Locals<1> v44
        Stack<11> v53 v58 v63 v68 v73 v78 v83 v88 v93 v98 v103
      }
    }
    Snapshot
    v109:Nullptr = LoadConst<Nullptr>
    v110:OptObject = LoadGlobalCached<12; "D">
    v111:MortalTypeExact[D:obj] = GuardIs<0xdeadbeef> v110 {
      Descr 'LOAD_GLOBAL: D'
    }
    Snapshot
    v113:Object = CallMethod<3> v109 v111 v44 {
      FrameState {
        NextInstrOffset 256
        Locals<1> v44
        Stack<12> v53 v58 v63 v68 v73 v78 v83 v88 v93 v98 v103 v108
      }
    }
    Snapshot
    v114:MortalTupleExact = MakeTuple<13> v53 v58 v63 v68 v73 v78 v83 v88 v93 v98 v103 v108 v113 {
      FrameState {
        NextInstrOffset 264
        Locals<1> v44
        Stack<13> v53 v58 v63 v68 v73 v78 v83 v88 v93 v98 v103 v108 v113
      }
    }
    Snapshot
    Return v114
  }
}
--- Test Name ---
TestInPlaceLongExact
--- Input ---
def test():
    x = 1
    x += 2
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v5:Nullptr = LoadConst<Nullptr>
    Snapshot
    v6:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v9:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    UseType<LongExact> v6
    UseType<LongExact> v9
    v13:LongExact = LongInPlaceOp<Add> v6 v9 {
      FrameState {
        NextInstrOffset 10
        Locals<1> v6
      }
    }
    Snapshot
    v12:NoneType = LoadConst<NoneType>
    Return v12
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v8:Func = LoadCurrentFunc
    v9:Nullptr = LoadConst<Nullptr>
    Snapshot
    v10:CInt32 = LoadEvalBreaker
    CondBranch<2, 1> v10
  }

  bb 2 (preds 0) {
    Snapshot
    v11:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 2
        Locals<1> v9
      }
    }
    Branch<1>
  }

  bb 1 (preds 0, 2) {
    Snapshot
    v13:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v16:ImmortalLongExact[2] = LoadConst<ImmortalLongExact[2]>
    UseType<LongExact> v13
    UseType<LongExact> v16
    v21:LongExact = LongInPlaceOp<Add> v13 v16 {
      FrameState {
        NextInstrOffset 12
        Locals<1> v13
      }
    }
    Snapshot
    v19:NoneType = LoadConst<NoneType>
    Return<NoneType> v19
  }
}
--- Test Name ---
TestInPlaceLongExactLoop
--- Input ---
def test():
    x = 1
    for i in range(10):
        x += 1
    return x
--- Expected 3.10 ---
fun jittestmodule:test {
  bb 0 {
    v12:Nullptr = LoadConst<Nullptr>
    Snapshot
    v13:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v15:OptObject = LoadGlobalCached<0; "range">
    v16:ImmortalTypeExact[range:obj] = GuardIs<0xdeadbeef> v15 {
      Descr 'LOAD_GLOBAL: range'
    }
    Snapshot
    v17:ImmortalLongExact[10] = LoadConst<ImmortalLongExact[10]>
    v18:Object = VectorCall<1> v16 v17 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v13 v12
      }
    }
    Snapshot
    v19:Object = GetIter v18 {
      FrameState {
        NextInstrOffset 12
        Locals<2> v13 v12
      }
    }
    Snapshot
    Branch<4>
  }

  bb 4 (preds 0, 2) {
    v23:LongExact = Phi<0, 2> v13 v37
    v24:OptObject = Phi<0, 2> v12 v29
    v21:CInt32 = LoadEvalBreaker
    CondBranch<5, 1> v21
  }

  bb 5 (preds 4) {
    Snapshot
    v25:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 12
        Locals<2> v23 v24
        Stack<1> v19
      }
    }
    Branch<1>
  }

  bb 1 (preds 4, 5) {
    Snapshot
    v29:Object = InvokeIterNext v19 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v23 v24
        Stack<1> v19
      }
    }
    CondBranchIterNotDone<2, 3> v29
  }

  bb 2 (preds 1) {
    Snapshot
    v33:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    UseType<LongExact> v23
    UseType<LongExact> v33
    v37:LongExact = LongInPlaceOp<Add> v23 v33 {
      FrameState {
        NextInstrOffset 22
        Locals<2> v23 v29
        Stack<1> v19
      }
    }
    Snapshot
    Branch<4>
  }

  bb 3 (preds 1) {
    Snapshot
    Return v23
  }
}
--- Expected 3.12 ---
fun jittestmodule:test {
  bb 0 {
    v12:Nullptr = LoadConst<Nullptr>
    Snapshot
    v13:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    v15:OptObject = LoadGlobalCached<0; "range">
    v16:ImmortalTypeExact[range:obj] = GuardIs<0xdeadbeef> v15 {
      Descr 'LOAD_GLOBAL: range'
    }
    Snapshot
    v17:ImmortalLongExact[10] = LoadConst<ImmortalLongExact[10]>
    v18:Object = VectorCall<1> v16 v17 {
      FrameState {
        NextInstrOffset 10
        Locals<2> v13 v12
      }
    }
    Snapshot
    v19:Object = GetIter v18 {
      FrameState {
        NextInstrOffset 12
        Locals<2> v13 v12
      }
    }
    Snapshot
    Branch<4>
  }

  bb 4 (preds 0, 2) {
    v23:LongExact = Phi<0, 2> v13 v37
    v24:OptObject = Phi<0, 2> v12 v29
    v21:CInt32 = LoadEvalBreaker
    CondBranch<5, 1> v21
  }

  bb 5 (preds 4) {
    Snapshot
    v25:CInt32 = RunPeriodicTasks {
      FrameState {
        NextInstrOffset 12
        Locals<2> v23 v24
        Stack<1> v19
      }
    }
    Branch<1>
  }

  bb 1 (preds 4, 5) {
    Snapshot
    v29:Object = InvokeIterNext v19 {
      FrameState {
        NextInstrOffset 14
        Locals<2> v23 v24
        Stack<1> v19
      }
    }
    CondBranchIterNotDone<2, 3> v29
  }

  bb 2 (preds 1) {
    Snapshot
    v33:ImmortalLongExact[1] = LoadConst<ImmortalLongExact[1]>
    UseType<LongExact> v23
    UseType<LongExact> v33
    v37:LongExact = LongInPlaceOp<Add> v23 v33 {
      FrameState {
        NextInstrOffset 22
        Locals<2> v23 v29
        Stack<1> v19
      }
    }
    Snapshot
    Branch<4>
  }

  bb 3 (preds 1) {
    Snapshot
    Return v23
  }
}
--- End ---
