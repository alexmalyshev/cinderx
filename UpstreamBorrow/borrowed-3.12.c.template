// -*- mode: c++ -*- vi: set ft=cpp:
// Copyright (c) Meta Platforms, Inc. and affiliates.

// This file is processed by UpstreamBorrow.py. To see the generated output:
// buck build -c cinderx.use_3_12=True --out=- fbcode//cinderx/UpstreamBorrow:gen_borrowed.c

// clang-format off

#include "cinderx/UpstreamBorrow/borrowed.h"

// @Borrow CPP directives from Objects/genobject.c

// Internal dependencies for _PyGen_yf which only exist in 3.12.
// @Borrow function is_resume from Objects/genobject.c
// @Borrow function _PyGen_GetCode from Objects/genobject.c
// End internal dependencies for _PyGen_yf.

#define _PyGen_yf Cix_PyGen_yf
// @Borrow function _PyGen_yf from Objects/genobject.c

// Internal dependencies for _PyCoro_GetAwaitableIter.
// @Borrow function gen_is_coroutine from Objects/genobject.c
// End internal dependencies for _PyCoro_GetAwaitableIter.

#define _PyCoro_GetAwaitableIter Cix_PyCoro_GetAwaitableIter
// @Borrow function _PyCoro_GetAwaitableIter from Objects/genobject.c

// Internal dependencies for _PyAsyncGenValueWrapperNew.
// @Borrow typedef _PyAsyncGenWrappedValue from Objects/genobject.c
// @Borrow function get_async_gen_state from Objects/genobject.c
// End internal dependencies for _PyAsyncGenValueWrapperNew.

// In 3.12 we need a temporary name before wrapping to avoid conflicting with
// the forward declaration in genobject.h.
#define _PyAsyncGenValueWrapperNew __PyAsyncGenValueWrapperNew
// @Borrow function _PyAsyncGenValueWrapperNew from Objects/genobject.c

// In 3.12 _PyAsyncGenValueWrapperNew needs thread-state. As this is used from
// the JIT we could get the value from the thread-state register. This would be
// slightly more efficient, but quite a bit more work and async-generators are
// rare. So we just wrap it up here.
PyObject* Cix_PyAsyncGenValueWrapperNew(PyObject* value) {
  return __PyAsyncGenValueWrapperNew(PyThreadState_GET(), value);
}

// _Py_IncRefTotal is used by internal functions in 3.12 dictobject.c.
// Pragmatically @Borrow'ing this doesn't seem worth it at this stage. We would
// need UpstreamBorrow.py to somehow not attempt/ignore failure to extract
// _Py_IncRefTotal on non-debug builds where it's deleted by the CPP. All the
// simple solutions I can think of seem just as ugly as manually copying. This
// is made worse by the fact internally _Py_IncRefTotal uses a macro which
// isn't easily visible to us as it's #undef'd after usage. So we'd need a fix
// or to copy that anyway.
#if defined(Py_DEBUG)
#define _Py_IncRefTotal __Py_IncRefTotal
static void _Py_IncRefTotal(PyInterpreterState* interp) {
  interp->object_state.reftotal++;
}

#define _Py_DecRefTotal __Py_DecRefTotal
static void _Py_DecRefTotal(PyInterpreterState* interp) {
  interp->object_state.reftotal--;
}
#endif

// @Borrow CPP directives from Objects/dictobject.c

// These are global singletons and some of the functions we're borrowing
// check for them with pointer equality. Fortunately we are able to get
// the values in init_upstream_borrow().
#undef Py_EMPTY_KEYS
static PyDictKeysObject* Py_EMPTY_KEYS = NULL;

// Internal dependencies for things borrowed from dictobject.c.
// @Borrow function dictkeys_get_index from Objects/dictobject.c
// @Borrow function unicode_get_hash from Objects/dictobject.c
// @Borrow function unicodekeys_lookup_unicode from Objects/dictobject.c
// @Borrow function unicodekeys_lookup_generic from Objects/dictobject.c
// @Borrow function dictkeys_generic_lookup from Objects/dictobject.c
// Rename to avoid clashing with existing version when statically linking.
#define _Py_dict_lookup __Py_dict_lookup
// @Borrow function _Py_dict_lookup from Objects/dictobject.c
// @Borrow function get_dict_state from Objects/dictobject.c
// @Borrow function new_values from Objects/dictobject.c
// @Borrow function free_values from Objects/dictobject.c
// @Borrow function shared_keys_usable_size from Objects/dictobject.c
// @Borrow function free_keys_object from Objects/dictobject.c
// @Borrow function dictkeys_decref from Objects/dictobject.c
// @Borrow function dictkeys_incref from Objects/dictobject.c
// @Borrow function new_dict from Objects/dictobject.c
// @Borrow function new_dict_with_shared_keys from Objects/dictobject.c
// @Borrow function dict_event_name from Objects/dictobject.c
// End internal dependencies.

#define _PyObjectDict_SetItem Cix_PyObjectDict_SetItem
// @Borrow function _PyObjectDict_SetItem from Objects/dictobject.c

#define _PyDict_LoadGlobal Cix_PyDict_LoadGlobal
// @Borrow function _PyDict_LoadGlobal from Objects/dictobject.c

// Include _PyDict_SendEvent with its original name but weakly as we use
// some static inline functions from CPython headers which depend on this.
__attribute__((weak))
// We do not rename to a Cix_ function as this is only used from static
// inline functions in CPython headers.
// @Borrow function _PyDict_SendEvent from Objects/dictobject.c

// @Borrow function set_attribute_error_context from Objects/object.c

// Wrapper as set_attribute_error_context is declared "static inline".
int
Cix_set_attribute_error_context(PyObject *v, PyObject *name) {
  return set_attribute_error_context(v, name);
}

// TODO: Get rid of this
// These are global singletons used transitively by _Py_union_type_or.
// We initialize them in init_upstream_borrow().
PyTypeObject* Cix_PyUnion_Type = NULL;
#define _PyUnion_Type (*Cix_PyUnion_Type)

PyTypeObject* Cix_PyTypeAlias_Type = NULL;
#define _PyTypeAlias_Type (*Cix_PyTypeAlias_Type)

// Internal dependencies for _PyThreadState_*Frame.
// @Borrow CPP directives from Objects/obmalloc.c
#define _PyObject_VirtualAlloc __PyObject_VirtualAlloc
// @Borrow function _PyObject_VirtualAlloc from Objects/obmalloc.c
#define _PyObject_VirtualFree __PyObject_VirtualFree
// @Borrow function _PyObject_VirtualFree from Objects/obmalloc.c
// @Borrow CPP directives from Python/pystate.c
// @Borrow function allocate_chunk from Python/pystate.c
// @Borrow function push_chunk from Python/pystate.c
// End internal dependencies.
#define _PyThreadState_PushFrame Cix_PyThreadState_PushFrame
// @Borrow function _PyThreadState_PushFrame from Python/pystate.c
#define _PyThreadState_PopFrame Cix_PyThreadState_PopFrame
// @Borrow function _PyThreadState_PopFrame from Python/pystate.c

// Internal dependencies for _PyFrame_ClearExceptCode.
// @Borrow CPP directives from Python/frame.c
__attribute__((weak))
// @Borrow function _PyFrame_New_NoTrack from Objects/frameobject.c
__attribute__((weak))
// @Borrow function _PyFrame_MakeAndSetFrameObject from Python/frame.c
// @Borrow function take_ownership from Python/frame.c
#define _PyFrame_ClearLocals __PyFrame_ClearLocals
// @Borrow function _PyFrame_ClearLocals from Python/frame.c
// End internal dependencies.
#define _PyFrame_ClearExceptCode Cix_PyFrame_ClearExceptCode
// @Borrow function _PyFrame_ClearExceptCode from Python/frame.c

// @Borrow var DE_INSTRUMENT from Python/instrumentation.c
uint8_t
Cix_DEINSTRUMENT(uint8_t op) {
  return DE_INSTRUMENT[op];
}

// Internal dependencies for bytecode address to line number mapping.
// @Borrow CPP directives from Objects/codeobject.c
// @Borrow function scan_varint from Objects/codeobject.c
// @Borrow function scan_signed_varint from Objects/codeobject.c
// @Borrow function get_line_delta from Objects/codeobject.c
// @Borrow function next_code_delta from Objects/codeobject.c
// @Borrow function is_no_line_marker from Objects/codeobject.c
// @Borrow function at_end from Objects/codeobject.c
// @Borrow function advance from Objects/codeobject.c
#define _PyLineTable_InitAddressRange __PyLineTable_InitAddressRange
// @Borrow function _PyLineTable_InitAddressRange from Objects/codeobject.c
// End internal dependencies.
#define _PyCode_InitAddressRange Cix_PyCode_InitAddressRange
// @Borrow function _PyCode_InitAddressRange from Objects/codeobject.c
#define _PyLineTable_NextAddressRange Cix_PyLineTable_NextAddressRange
// @Borrow function _PyLineTable_NextAddressRange from Objects/codeobject.c

// Internal dependencies for Cix_do_raise.
#define _PyErr_SetRaisedException __PyErr_SetRaisedException
// @Borrow function _PyErr_SetRaisedException from Python/errors.c
// End internal dependencies.
// @Borrow function do_raise from Python/ceval.c
int Cix_do_raise(PyThreadState* tstate, PyObject* exc, PyObject* cause) {
  return do_raise(tstate, exc, cause);
}

int init_upstream_borrow(void) {
  PyObject* empty_dict = PyDict_New();
  if (empty_dict == NULL) {
    return -1;
  }
  Py_EMPTY_KEYS = ((PyDictObject*)empty_dict)->ma_keys;
  Py_DECREF(empty_dict);

  // Initialize the Cix_PyUnion_Type global reference.
  PyObject* unionobj =
      PyNumber_Or((PyObject*)&PyLong_Type, (PyObject*)&PyUnicode_Type);
  if (unionobj != NULL) {
    Cix_PyUnion_Type = Py_TYPE(unionobj);
    Py_DECREF(unionobj);
  }
  if (Cix_PyUnion_Type == NULL) {
    return -1;
  }

  // Initialize the Cix_PyTypeAlias_Type global reference.
  PyObject* typing_module = PyImport_ImportModule("typing");
  if (!typing_module) {
    return -1;
  }
  PyObject* type_alias_type =
      PyObject_GetAttrString(typing_module, "TypeAliasType");

  if (!type_alias_type) {
    Py_DECREF(typing_module);
    return -1;
  }
  assert(PyType_Check(type_alias_type));
  Cix_PyTypeAlias_Type = (PyTypeObject*)type_alias_type;
  Py_DECREF(typing_module);

  return 0;
}
